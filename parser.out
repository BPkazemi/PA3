Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> CLASSDEF semi
Rule 2     PROGRAM -> PROGRAM CLASSDEF semi
Rule 3     CLASSDEF -> class type lbrace rbrace
Rule 4     CLASSDEF -> class type lbrace FEATURE semi rbrace
Rule 5     CLASSDEF -> class type inherits type lbrace rbrace
Rule 6     CLASSDEF -> class type inherits type lbrace FEATURE rbrace
Rule 7     FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
Rule 8     FEATURE -> identifier colon type
Rule 9     FEATURE -> identifier colon type larrow EXPR
Rule 10    FEATURE -> FEATURE semi FEATURE
Rule 11    FORMAL -> identifier colon type
Rule 12    FORMAL -> FORMAL comma identifier colon type
Rule 13    FORMAL -> <empty>
Rule 14    EXPR -> case EXPR of CASEHELPER esac
Rule 15    CASEHELPER -> identifier colon type rarrow EXPR semi
Rule 16    CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi
Rule 17    CASEHELPER -> <empty>
Rule 18    LETHELPER -> comma identifier colon type LETHELPER
Rule 19    LETHELPER -> comma identifier colon type larrow EXPR LETHELPER
Rule 20    LETHELPER -> <empty>
Rule 21    EXPR -> EXPR at type dot identifier lparen EXPR rparen
Rule 22    EXPR -> EXPR dot identifier lparen EXPR rparen
Rule 23    EXPR -> let identifier colon type LETHELPER in EXPR
Rule 24    EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR
Rule 25    EXPR -> lparen EXPR rparen
Rule 26    EXPR -> lbrace EXPR semi rbrace
Rule 27    EXPR -> identifier larrow EXPR
Rule 28    EXPR -> identifier lparen EXPR rparen
Rule 29    EXPR -> EXPR at type dot identifier lparen rparen
Rule 30    EXPR -> EXPR dot identifier lparen rparen
Rule 31    EXPR -> if EXPR then EXPR else EXPR fi
Rule 32    EXPR -> while EXPR loop EXPR pool
Rule 33    EXPR -> EXPR comma EXPR
Rule 34    EXPR -> EXPR semi EXPR
Rule 35    EXPR -> isvoid EXPR
Rule 36    EXPR -> tilde EXPR
Rule 37    EXPR -> not EXPR
Rule 38    EXPR -> EXPR plus EXPR
Rule 39    EXPR -> EXPR minus EXPR
Rule 40    EXPR -> EXPR times EXPR
Rule 41    EXPR -> EXPR divide EXPR
Rule 42    EXPR -> EXPR lt EXPR
Rule 43    EXPR -> EXPR le EXPR
Rule 44    EXPR -> EXPR equals EXPR
Rule 45    EXPR -> identifier
Rule 46    EXPR -> integer
Rule 47    EXPR -> string
Rule 48    EXPR -> true
Rule 49    EXPR -> false
Rule 50    EXPR -> identifier lparen rparen
Rule 51    EXPR -> new type

Terminals, with rules where they appear

at                   : 21 29
case                 : 14
class                : 3 4 5 6
colon                : 7 8 9 11 12 15 16 18 19 23 24
comma                : 12 18 19 33
divide               : 41
dot                  : 21 22 29 30
else                 : 31
equals               : 44
error                : 
esac                 : 14
false                : 49
fi                   : 31
identifier           : 7 8 9 11 12 15 16 18 19 21 22 23 24 27 28 29 30 45 50
if                   : 31
in                   : 23 24
inherits             : 5 6
integer              : 46
isvoid               : 35
larrow               : 9 19 24 27
lbrace               : 3 4 5 6 7 26
le                   : 43
let                  : 23 24
loop                 : 32
lparen               : 7 21 22 25 28 29 30 50
lt                   : 42
minus                : 39
new                  : 51
not                  : 37
of                   : 14
plus                 : 38
pool                 : 32
rarrow               : 15 16
rbrace               : 3 4 5 6 7 26
rparen               : 7 21 22 25 28 29 30 50
semi                 : 1 2 4 10 15 16 26 34
string               : 47
then                 : 31
tilde                : 36
times                : 40
true                 : 48
type                 : 3 4 5 5 6 6 7 8 9 11 12 15 16 18 19 21 23 24 29 51
while                : 32

Nonterminals, with rules where they appear

CASEHELPER           : 14 16
CLASSDEF             : 1 2
EXPR                 : 7 9 14 15 16 19 21 21 22 22 23 24 24 25 26 27 28 29 30 31 31 31 32 32 33 33 34 34 35 36 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44
FEATURE              : 4 6 10 10
FORMAL               : 7 12
LETHELPER            : 18 19 23 24
PROGRAM              : 2 0

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . CLASSDEF semi
    (2) PROGRAM -> . PROGRAM CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE rbrace

    class           shift and go to state 3

    PROGRAM                        shift and go to state 2
    CLASSDEF                       shift and go to state 1

state 1

    (1) PROGRAM -> CLASSDEF . semi

    semi            shift and go to state 4


state 2

    (0) S' -> PROGRAM .
    (2) PROGRAM -> PROGRAM . CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE rbrace

    class           shift and go to state 3

    CLASSDEF                       shift and go to state 5

state 3

    (3) CLASSDEF -> class . type lbrace rbrace
    (4) CLASSDEF -> class . type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class . type inherits type lbrace rbrace
    (6) CLASSDEF -> class . type inherits type lbrace FEATURE rbrace

    type            shift and go to state 6


state 4

    (1) PROGRAM -> CLASSDEF semi .

    class           reduce using rule 1 (PROGRAM -> CLASSDEF semi .)
    $end            reduce using rule 1 (PROGRAM -> CLASSDEF semi .)


state 5

    (2) PROGRAM -> PROGRAM CLASSDEF . semi

    semi            shift and go to state 7


state 6

    (3) CLASSDEF -> class type . lbrace rbrace
    (4) CLASSDEF -> class type . lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class type . inherits type lbrace rbrace
    (6) CLASSDEF -> class type . inherits type lbrace FEATURE rbrace

    lbrace          shift and go to state 9
    inherits        shift and go to state 8


state 7

    (2) PROGRAM -> PROGRAM CLASSDEF semi .

    class           reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)
    $end            reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)


state 8

    (5) CLASSDEF -> class type inherits . type lbrace rbrace
    (6) CLASSDEF -> class type inherits . type lbrace FEATURE rbrace

    type            shift and go to state 10


state 9

    (3) CLASSDEF -> class type lbrace . rbrace
    (4) CLASSDEF -> class type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier colon type
    (9) FEATURE -> . identifier colon type larrow EXPR
    (10) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 11
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 12

state 10

    (5) CLASSDEF -> class type inherits type . lbrace rbrace
    (6) CLASSDEF -> class type inherits type . lbrace FEATURE rbrace

    lbrace          shift and go to state 14


state 11

    (3) CLASSDEF -> class type lbrace rbrace .

    semi            reduce using rule 3 (CLASSDEF -> class type lbrace rbrace .)


state 12

    (4) CLASSDEF -> class type lbrace FEATURE . semi rbrace
    (10) FEATURE -> FEATURE . semi FEATURE

    semi            shift and go to state 15


state 13

    (7) FEATURE -> identifier . lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier . colon type
    (9) FEATURE -> identifier . colon type larrow EXPR

    lparen          shift and go to state 17
    colon           shift and go to state 16


state 14

    (5) CLASSDEF -> class type inherits type lbrace . rbrace
    (6) CLASSDEF -> class type inherits type lbrace . FEATURE rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier colon type
    (9) FEATURE -> . identifier colon type larrow EXPR
    (10) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 18
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 19

state 15

    (4) CLASSDEF -> class type lbrace FEATURE semi . rbrace
    (10) FEATURE -> FEATURE semi . FEATURE
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier colon type
    (9) FEATURE -> . identifier colon type larrow EXPR
    (10) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 20
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 21

state 16

    (8) FEATURE -> identifier colon . type
    (9) FEATURE -> identifier colon . type larrow EXPR

    type            shift and go to state 22


state 17

    (7) FEATURE -> identifier lparen . FORMAL rparen colon type lbrace EXPR rbrace
    (11) FORMAL -> . identifier colon type
    (12) FORMAL -> . FORMAL comma identifier colon type
    (13) FORMAL -> .

    identifier      shift and go to state 23
    rparen          reduce using rule 13 (FORMAL -> .)
    comma           reduce using rule 13 (FORMAL -> .)

    FORMAL                         shift and go to state 24

state 18

    (5) CLASSDEF -> class type inherits type lbrace rbrace .

    semi            reduce using rule 5 (CLASSDEF -> class type inherits type lbrace rbrace .)


state 19

    (6) CLASSDEF -> class type inherits type lbrace FEATURE . rbrace
    (10) FEATURE -> FEATURE . semi FEATURE

    rbrace          shift and go to state 25
    semi            shift and go to state 26


state 20

    (4) CLASSDEF -> class type lbrace FEATURE semi rbrace .

    semi            reduce using rule 4 (CLASSDEF -> class type lbrace FEATURE semi rbrace .)


state 21

    (10) FEATURE -> FEATURE semi FEATURE .
    (10) FEATURE -> FEATURE . semi FEATURE

  ! shift/reduce conflict for semi resolved as shift
    rbrace          reduce using rule 10 (FEATURE -> FEATURE semi FEATURE .)
    semi            shift and go to state 26

  ! semi            [ reduce using rule 10 (FEATURE -> FEATURE semi FEATURE .) ]


state 22

    (8) FEATURE -> identifier colon type .
    (9) FEATURE -> identifier colon type . larrow EXPR

    semi            reduce using rule 8 (FEATURE -> identifier colon type .)
    rbrace          reduce using rule 8 (FEATURE -> identifier colon type .)
    larrow          shift and go to state 27


state 23

    (11) FORMAL -> identifier . colon type

    colon           shift and go to state 28


state 24

    (7) FEATURE -> identifier lparen FORMAL . rparen colon type lbrace EXPR rbrace
    (12) FORMAL -> FORMAL . comma identifier colon type

    rparen          shift and go to state 29
    comma           shift and go to state 30


state 25

    (6) CLASSDEF -> class type inherits type lbrace FEATURE rbrace .

    semi            reduce using rule 6 (CLASSDEF -> class type inherits type lbrace FEATURE rbrace .)


state 26

    (10) FEATURE -> FEATURE semi . FEATURE
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier colon type
    (9) FEATURE -> . identifier colon type larrow EXPR
    (10) FEATURE -> . FEATURE semi FEATURE

    identifier      shift and go to state 13

    FEATURE                        shift and go to state 21

state 27

    (9) FEATURE -> identifier colon type larrow . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 35

state 28

    (11) FORMAL -> identifier colon . type

    type            shift and go to state 47


state 29

    (7) FEATURE -> identifier lparen FORMAL rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 48


state 30

    (12) FORMAL -> FORMAL comma . identifier colon type

    identifier      shift and go to state 49


state 31

    (49) EXPR -> false .

    at              reduce using rule 49 (EXPR -> false .)
    dot             reduce using rule 49 (EXPR -> false .)
    comma           reduce using rule 49 (EXPR -> false .)
    semi            reduce using rule 49 (EXPR -> false .)
    plus            reduce using rule 49 (EXPR -> false .)
    minus           reduce using rule 49 (EXPR -> false .)
    times           reduce using rule 49 (EXPR -> false .)
    divide          reduce using rule 49 (EXPR -> false .)
    lt              reduce using rule 49 (EXPR -> false .)
    le              reduce using rule 49 (EXPR -> false .)
    equals          reduce using rule 49 (EXPR -> false .)
    in              reduce using rule 49 (EXPR -> false .)
    rbrace          reduce using rule 49 (EXPR -> false .)
    then            reduce using rule 49 (EXPR -> false .)
    rparen          reduce using rule 49 (EXPR -> false .)
    of              reduce using rule 49 (EXPR -> false .)
    loop            reduce using rule 49 (EXPR -> false .)
    else            reduce using rule 49 (EXPR -> false .)
    pool            reduce using rule 49 (EXPR -> false .)
    fi              reduce using rule 49 (EXPR -> false .)


state 32

    (36) EXPR -> tilde . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 50

state 33

    (31) EXPR -> if . EXPR then EXPR else EXPR fi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 51

state 34

    (46) EXPR -> integer .

    at              reduce using rule 46 (EXPR -> integer .)
    dot             reduce using rule 46 (EXPR -> integer .)
    comma           reduce using rule 46 (EXPR -> integer .)
    semi            reduce using rule 46 (EXPR -> integer .)
    plus            reduce using rule 46 (EXPR -> integer .)
    minus           reduce using rule 46 (EXPR -> integer .)
    times           reduce using rule 46 (EXPR -> integer .)
    divide          reduce using rule 46 (EXPR -> integer .)
    lt              reduce using rule 46 (EXPR -> integer .)
    le              reduce using rule 46 (EXPR -> integer .)
    equals          reduce using rule 46 (EXPR -> integer .)
    in              reduce using rule 46 (EXPR -> integer .)
    rbrace          reduce using rule 46 (EXPR -> integer .)
    then            reduce using rule 46 (EXPR -> integer .)
    rparen          reduce using rule 46 (EXPR -> integer .)
    of              reduce using rule 46 (EXPR -> integer .)
    loop            reduce using rule 46 (EXPR -> integer .)
    else            reduce using rule 46 (EXPR -> integer .)
    pool            reduce using rule 46 (EXPR -> integer .)
    fi              reduce using rule 46 (EXPR -> integer .)


state 35

    (9) FEATURE -> identifier colon type larrow EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 9 (FEATURE -> identifier colon type larrow EXPR .)
    rbrace          reduce using rule 9 (FEATURE -> identifier colon type larrow EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! semi            [ shift and go to state 54 ]


state 36

    (35) EXPR -> isvoid . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 63

state 37

    (47) EXPR -> string .

    at              reduce using rule 47 (EXPR -> string .)
    dot             reduce using rule 47 (EXPR -> string .)
    comma           reduce using rule 47 (EXPR -> string .)
    semi            reduce using rule 47 (EXPR -> string .)
    plus            reduce using rule 47 (EXPR -> string .)
    minus           reduce using rule 47 (EXPR -> string .)
    times           reduce using rule 47 (EXPR -> string .)
    divide          reduce using rule 47 (EXPR -> string .)
    lt              reduce using rule 47 (EXPR -> string .)
    le              reduce using rule 47 (EXPR -> string .)
    equals          reduce using rule 47 (EXPR -> string .)
    in              reduce using rule 47 (EXPR -> string .)
    rbrace          reduce using rule 47 (EXPR -> string .)
    then            reduce using rule 47 (EXPR -> string .)
    rparen          reduce using rule 47 (EXPR -> string .)
    of              reduce using rule 47 (EXPR -> string .)
    loop            reduce using rule 47 (EXPR -> string .)
    else            reduce using rule 47 (EXPR -> string .)
    pool            reduce using rule 47 (EXPR -> string .)
    fi              reduce using rule 47 (EXPR -> string .)


state 38

    (23) EXPR -> let . identifier colon type LETHELPER in EXPR
    (24) EXPR -> let . identifier colon type larrow EXPR LETHELPER in EXPR

    identifier      shift and go to state 64


state 39

    (25) EXPR -> lparen . EXPR rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 65

state 40

    (51) EXPR -> new . type

    type            shift and go to state 66


state 41

    (37) EXPR -> not . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 67

state 42

    (48) EXPR -> true .

    at              reduce using rule 48 (EXPR -> true .)
    dot             reduce using rule 48 (EXPR -> true .)
    comma           reduce using rule 48 (EXPR -> true .)
    semi            reduce using rule 48 (EXPR -> true .)
    plus            reduce using rule 48 (EXPR -> true .)
    minus           reduce using rule 48 (EXPR -> true .)
    times           reduce using rule 48 (EXPR -> true .)
    divide          reduce using rule 48 (EXPR -> true .)
    lt              reduce using rule 48 (EXPR -> true .)
    le              reduce using rule 48 (EXPR -> true .)
    equals          reduce using rule 48 (EXPR -> true .)
    in              reduce using rule 48 (EXPR -> true .)
    rbrace          reduce using rule 48 (EXPR -> true .)
    then            reduce using rule 48 (EXPR -> true .)
    rparen          reduce using rule 48 (EXPR -> true .)
    of              reduce using rule 48 (EXPR -> true .)
    loop            reduce using rule 48 (EXPR -> true .)
    else            reduce using rule 48 (EXPR -> true .)
    pool            reduce using rule 48 (EXPR -> true .)
    fi              reduce using rule 48 (EXPR -> true .)


state 43

    (14) EXPR -> case . EXPR of CASEHELPER esac
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 68

state 44

    (26) EXPR -> lbrace . EXPR semi rbrace
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 69

state 45

    (32) EXPR -> while . EXPR loop EXPR pool
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 70

state 46

    (27) EXPR -> identifier . larrow EXPR
    (28) EXPR -> identifier . lparen EXPR rparen
    (45) EXPR -> identifier .
    (50) EXPR -> identifier . lparen rparen

    larrow          shift and go to state 71
    lparen          shift and go to state 72
    at              reduce using rule 45 (EXPR -> identifier .)
    dot             reduce using rule 45 (EXPR -> identifier .)
    comma           reduce using rule 45 (EXPR -> identifier .)
    semi            reduce using rule 45 (EXPR -> identifier .)
    plus            reduce using rule 45 (EXPR -> identifier .)
    minus           reduce using rule 45 (EXPR -> identifier .)
    times           reduce using rule 45 (EXPR -> identifier .)
    divide          reduce using rule 45 (EXPR -> identifier .)
    lt              reduce using rule 45 (EXPR -> identifier .)
    le              reduce using rule 45 (EXPR -> identifier .)
    equals          reduce using rule 45 (EXPR -> identifier .)
    in              reduce using rule 45 (EXPR -> identifier .)
    rbrace          reduce using rule 45 (EXPR -> identifier .)
    then            reduce using rule 45 (EXPR -> identifier .)
    rparen          reduce using rule 45 (EXPR -> identifier .)
    of              reduce using rule 45 (EXPR -> identifier .)
    loop            reduce using rule 45 (EXPR -> identifier .)
    else            reduce using rule 45 (EXPR -> identifier .)
    pool            reduce using rule 45 (EXPR -> identifier .)
    fi              reduce using rule 45 (EXPR -> identifier .)


state 47

    (11) FORMAL -> identifier colon type .

    rparen          reduce using rule 11 (FORMAL -> identifier colon type .)
    comma           reduce using rule 11 (FORMAL -> identifier colon type .)


state 48

    (7) FEATURE -> identifier lparen FORMAL rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 73


state 49

    (12) FORMAL -> FORMAL comma identifier . colon type

    colon           shift and go to state 74


state 50

    (36) EXPR -> tilde EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 36 (EXPR -> tilde EXPR .)
    semi            reduce using rule 36 (EXPR -> tilde EXPR .)
    plus            reduce using rule 36 (EXPR -> tilde EXPR .)
    minus           reduce using rule 36 (EXPR -> tilde EXPR .)
    times           reduce using rule 36 (EXPR -> tilde EXPR .)
    divide          reduce using rule 36 (EXPR -> tilde EXPR .)
    lt              reduce using rule 36 (EXPR -> tilde EXPR .)
    le              reduce using rule 36 (EXPR -> tilde EXPR .)
    equals          reduce using rule 36 (EXPR -> tilde EXPR .)
    in              reduce using rule 36 (EXPR -> tilde EXPR .)
    rbrace          reduce using rule 36 (EXPR -> tilde EXPR .)
    then            reduce using rule 36 (EXPR -> tilde EXPR .)
    rparen          reduce using rule 36 (EXPR -> tilde EXPR .)
    of              reduce using rule 36 (EXPR -> tilde EXPR .)
    loop            reduce using rule 36 (EXPR -> tilde EXPR .)
    else            reduce using rule 36 (EXPR -> tilde EXPR .)
    pool            reduce using rule 36 (EXPR -> tilde EXPR .)
    fi              reduce using rule 36 (EXPR -> tilde EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62

  ! at              [ reduce using rule 36 (EXPR -> tilde EXPR .) ]
  ! dot             [ reduce using rule 36 (EXPR -> tilde EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! plus            [ shift and go to state 52 ]
  ! minus           [ shift and go to state 61 ]
  ! times           [ shift and go to state 56 ]
  ! divide          [ shift and go to state 53 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 51

    (31) EXPR -> if EXPR . then EXPR else EXPR fi
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    then            shift and go to state 75
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 52

    (38) EXPR -> EXPR plus . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 76

state 53

    (41) EXPR -> EXPR divide . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 77

state 54

    (34) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 78

state 55

    (44) EXPR -> EXPR equals . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 79

state 56

    (40) EXPR -> EXPR times . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 80

state 57

    (42) EXPR -> EXPR lt . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 81

state 58

    (43) EXPR -> EXPR le . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 82

state 59

    (21) EXPR -> EXPR at . type dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR at . type dot identifier lparen rparen

    type            shift and go to state 83


state 60

    (33) EXPR -> EXPR comma . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 84

state 61

    (39) EXPR -> EXPR minus . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 85

state 62

    (22) EXPR -> EXPR dot . identifier lparen EXPR rparen
    (30) EXPR -> EXPR dot . identifier lparen rparen

    identifier      shift and go to state 86


state 63

    (35) EXPR -> isvoid EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 35 (EXPR -> isvoid EXPR .)
    semi            reduce using rule 35 (EXPR -> isvoid EXPR .)
    plus            reduce using rule 35 (EXPR -> isvoid EXPR .)
    minus           reduce using rule 35 (EXPR -> isvoid EXPR .)
    times           reduce using rule 35 (EXPR -> isvoid EXPR .)
    divide          reduce using rule 35 (EXPR -> isvoid EXPR .)
    lt              reduce using rule 35 (EXPR -> isvoid EXPR .)
    le              reduce using rule 35 (EXPR -> isvoid EXPR .)
    equals          reduce using rule 35 (EXPR -> isvoid EXPR .)
    in              reduce using rule 35 (EXPR -> isvoid EXPR .)
    rbrace          reduce using rule 35 (EXPR -> isvoid EXPR .)
    then            reduce using rule 35 (EXPR -> isvoid EXPR .)
    rparen          reduce using rule 35 (EXPR -> isvoid EXPR .)
    of              reduce using rule 35 (EXPR -> isvoid EXPR .)
    loop            reduce using rule 35 (EXPR -> isvoid EXPR .)
    else            reduce using rule 35 (EXPR -> isvoid EXPR .)
    pool            reduce using rule 35 (EXPR -> isvoid EXPR .)
    fi              reduce using rule 35 (EXPR -> isvoid EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62

  ! at              [ reduce using rule 35 (EXPR -> isvoid EXPR .) ]
  ! dot             [ reduce using rule 35 (EXPR -> isvoid EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! plus            [ shift and go to state 52 ]
  ! minus           [ shift and go to state 61 ]
  ! times           [ shift and go to state 56 ]
  ! divide          [ shift and go to state 53 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 64

    (23) EXPR -> let identifier . colon type LETHELPER in EXPR
    (24) EXPR -> let identifier . colon type larrow EXPR LETHELPER in EXPR

    colon           shift and go to state 87


state 65

    (25) EXPR -> lparen EXPR . rparen
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 88
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 66

    (51) EXPR -> new type .

    at              reduce using rule 51 (EXPR -> new type .)
    dot             reduce using rule 51 (EXPR -> new type .)
    comma           reduce using rule 51 (EXPR -> new type .)
    semi            reduce using rule 51 (EXPR -> new type .)
    plus            reduce using rule 51 (EXPR -> new type .)
    minus           reduce using rule 51 (EXPR -> new type .)
    times           reduce using rule 51 (EXPR -> new type .)
    divide          reduce using rule 51 (EXPR -> new type .)
    lt              reduce using rule 51 (EXPR -> new type .)
    le              reduce using rule 51 (EXPR -> new type .)
    equals          reduce using rule 51 (EXPR -> new type .)
    in              reduce using rule 51 (EXPR -> new type .)
    rbrace          reduce using rule 51 (EXPR -> new type .)
    then            reduce using rule 51 (EXPR -> new type .)
    rparen          reduce using rule 51 (EXPR -> new type .)
    of              reduce using rule 51 (EXPR -> new type .)
    loop            reduce using rule 51 (EXPR -> new type .)
    else            reduce using rule 51 (EXPR -> new type .)
    pool            reduce using rule 51 (EXPR -> new type .)
    fi              reduce using rule 51 (EXPR -> new type .)


state 67

    (37) EXPR -> not EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 37 (EXPR -> not EXPR .)
    semi            reduce using rule 37 (EXPR -> not EXPR .)
    in              reduce using rule 37 (EXPR -> not EXPR .)
    rbrace          reduce using rule 37 (EXPR -> not EXPR .)
    then            reduce using rule 37 (EXPR -> not EXPR .)
    rparen          reduce using rule 37 (EXPR -> not EXPR .)
    of              reduce using rule 37 (EXPR -> not EXPR .)
    loop            reduce using rule 37 (EXPR -> not EXPR .)
    else            reduce using rule 37 (EXPR -> not EXPR .)
    pool            reduce using rule 37 (EXPR -> not EXPR .)
    fi              reduce using rule 37 (EXPR -> not EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! at              [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! dot             [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! plus            [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! minus           [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! times           [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! divide          [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! lt              [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! le              [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! equals          [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]


state 68

    (14) EXPR -> case EXPR . of CASEHELPER esac
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    of              shift and go to state 89
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 69

    (26) EXPR -> lbrace EXPR . semi rbrace
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 90
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 70

    (32) EXPR -> while EXPR . loop EXPR pool
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    loop            shift and go to state 91
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 71

    (27) EXPR -> identifier larrow . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 92

state 72

    (28) EXPR -> identifier lparen . EXPR rparen
    (50) EXPR -> identifier lparen . rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    rparen          shift and go to state 94
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 93

state 73

    (7) FEATURE -> identifier lparen FORMAL rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 95


state 74

    (12) FORMAL -> FORMAL comma identifier colon . type

    type            shift and go to state 96


state 75

    (31) EXPR -> if EXPR then . EXPR else EXPR fi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 97

state 76

    (38) EXPR -> EXPR plus EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    semi            reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    plus            reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    lt              reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    le              reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    in              reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    rbrace          reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    then            reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    rparen          reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    of              reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    loop            reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    pool            reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    fi              reduce using rule 38 (EXPR -> EXPR plus EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    times           shift and go to state 56
    divide          shift and go to state 53

  ! at              [ reduce using rule 38 (EXPR -> EXPR plus EXPR .) ]
  ! dot             [ reduce using rule 38 (EXPR -> EXPR plus EXPR .) ]
  ! times           [ reduce using rule 38 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 38 (EXPR -> EXPR plus EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! plus            [ shift and go to state 52 ]
  ! minus           [ shift and go to state 61 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 77

    (41) EXPR -> EXPR divide EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    semi            reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    plus            reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    lt              reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    le              reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    in              reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    rbrace          reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    then            reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    rparen          reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    of              reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    loop            reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    pool            reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    fi              reduce using rule 41 (EXPR -> EXPR divide EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62

  ! at              [ reduce using rule 41 (EXPR -> EXPR divide EXPR .) ]
  ! dot             [ reduce using rule 41 (EXPR -> EXPR divide EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! plus            [ shift and go to state 52 ]
  ! minus           [ shift and go to state 61 ]
  ! times           [ shift and go to state 56 ]
  ! divide          [ shift and go to state 53 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 78

    (34) EXPR -> EXPR semi EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    in              reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    rbrace          reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    then            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    rparen          reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    of              reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    loop            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    else            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    pool            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    fi              reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! at              [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! dot             [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! comma           [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! semi            [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! plus            [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! minus           [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! times           [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! divide          [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! lt              [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! le              [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! equals          [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]


state 79

    (44) EXPR -> EXPR equals EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    semi            reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    lt              reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    le              reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    equals          reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    in              reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    rbrace          reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    then            reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    rparen          reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    of              reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    loop            reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    else            reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    pool            reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    fi              reduce using rule 44 (EXPR -> EXPR equals EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53

  ! at              [ reduce using rule 44 (EXPR -> EXPR equals EXPR .) ]
  ! dot             [ reduce using rule 44 (EXPR -> EXPR equals EXPR .) ]
  ! plus            [ reduce using rule 44 (EXPR -> EXPR equals EXPR .) ]
  ! minus           [ reduce using rule 44 (EXPR -> EXPR equals EXPR .) ]
  ! times           [ reduce using rule 44 (EXPR -> EXPR equals EXPR .) ]
  ! divide          [ reduce using rule 44 (EXPR -> EXPR equals EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 80

    (40) EXPR -> EXPR times EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 40 (EXPR -> EXPR times EXPR .)
    semi            reduce using rule 40 (EXPR -> EXPR times EXPR .)
    plus            reduce using rule 40 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 40 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 40 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 40 (EXPR -> EXPR times EXPR .)
    lt              reduce using rule 40 (EXPR -> EXPR times EXPR .)
    le              reduce using rule 40 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 40 (EXPR -> EXPR times EXPR .)
    in              reduce using rule 40 (EXPR -> EXPR times EXPR .)
    rbrace          reduce using rule 40 (EXPR -> EXPR times EXPR .)
    then            reduce using rule 40 (EXPR -> EXPR times EXPR .)
    rparen          reduce using rule 40 (EXPR -> EXPR times EXPR .)
    of              reduce using rule 40 (EXPR -> EXPR times EXPR .)
    loop            reduce using rule 40 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 40 (EXPR -> EXPR times EXPR .)
    pool            reduce using rule 40 (EXPR -> EXPR times EXPR .)
    fi              reduce using rule 40 (EXPR -> EXPR times EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62

  ! at              [ reduce using rule 40 (EXPR -> EXPR times EXPR .) ]
  ! dot             [ reduce using rule 40 (EXPR -> EXPR times EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! plus            [ shift and go to state 52 ]
  ! minus           [ shift and go to state 61 ]
  ! times           [ shift and go to state 56 ]
  ! divide          [ shift and go to state 53 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 81

    (42) EXPR -> EXPR lt EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    semi            reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    lt              reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    le              reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    equals          reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    in              reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    rbrace          reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    then            reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    rparen          reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    of              reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    loop            reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    else            reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    pool            reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    fi              reduce using rule 42 (EXPR -> EXPR lt EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53

  ! at              [ reduce using rule 42 (EXPR -> EXPR lt EXPR .) ]
  ! dot             [ reduce using rule 42 (EXPR -> EXPR lt EXPR .) ]
  ! plus            [ reduce using rule 42 (EXPR -> EXPR lt EXPR .) ]
  ! minus           [ reduce using rule 42 (EXPR -> EXPR lt EXPR .) ]
  ! times           [ reduce using rule 42 (EXPR -> EXPR lt EXPR .) ]
  ! divide          [ reduce using rule 42 (EXPR -> EXPR lt EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 82

    (43) EXPR -> EXPR le EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 43 (EXPR -> EXPR le EXPR .)
    semi            reduce using rule 43 (EXPR -> EXPR le EXPR .)
    lt              reduce using rule 43 (EXPR -> EXPR le EXPR .)
    le              reduce using rule 43 (EXPR -> EXPR le EXPR .)
    equals          reduce using rule 43 (EXPR -> EXPR le EXPR .)
    in              reduce using rule 43 (EXPR -> EXPR le EXPR .)
    rbrace          reduce using rule 43 (EXPR -> EXPR le EXPR .)
    then            reduce using rule 43 (EXPR -> EXPR le EXPR .)
    rparen          reduce using rule 43 (EXPR -> EXPR le EXPR .)
    of              reduce using rule 43 (EXPR -> EXPR le EXPR .)
    loop            reduce using rule 43 (EXPR -> EXPR le EXPR .)
    else            reduce using rule 43 (EXPR -> EXPR le EXPR .)
    pool            reduce using rule 43 (EXPR -> EXPR le EXPR .)
    fi              reduce using rule 43 (EXPR -> EXPR le EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53

  ! at              [ reduce using rule 43 (EXPR -> EXPR le EXPR .) ]
  ! dot             [ reduce using rule 43 (EXPR -> EXPR le EXPR .) ]
  ! plus            [ reduce using rule 43 (EXPR -> EXPR le EXPR .) ]
  ! minus           [ reduce using rule 43 (EXPR -> EXPR le EXPR .) ]
  ! times           [ reduce using rule 43 (EXPR -> EXPR le EXPR .) ]
  ! divide          [ reduce using rule 43 (EXPR -> EXPR le EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 83

    (21) EXPR -> EXPR at type . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR at type . dot identifier lparen rparen

    dot             shift and go to state 98


state 84

    (33) EXPR -> EXPR comma EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    in              reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    rbrace          reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    then            reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    rparen          reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    of              reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    loop            reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    else            reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    pool            reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    fi              reduce using rule 33 (EXPR -> EXPR comma EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! at              [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! dot             [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! comma           [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! semi            [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! plus            [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! minus           [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! times           [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! divide          [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! lt              [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! le              [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]
  ! equals          [ reduce using rule 33 (EXPR -> EXPR comma EXPR .) ]


state 85

    (39) EXPR -> EXPR minus EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    semi            reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    plus            reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    lt              reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    le              reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    in              reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    rbrace          reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    then            reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    rparen          reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    of              reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    loop            reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    pool            reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    fi              reduce using rule 39 (EXPR -> EXPR minus EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    times           shift and go to state 56
    divide          shift and go to state 53

  ! at              [ reduce using rule 39 (EXPR -> EXPR minus EXPR .) ]
  ! dot             [ reduce using rule 39 (EXPR -> EXPR minus EXPR .) ]
  ! times           [ reduce using rule 39 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 39 (EXPR -> EXPR minus EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]
  ! plus            [ shift and go to state 52 ]
  ! minus           [ shift and go to state 61 ]
  ! lt              [ shift and go to state 57 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 55 ]


state 86

    (22) EXPR -> EXPR dot identifier . lparen EXPR rparen
    (30) EXPR -> EXPR dot identifier . lparen rparen

    lparen          shift and go to state 99


state 87

    (23) EXPR -> let identifier colon . type LETHELPER in EXPR
    (24) EXPR -> let identifier colon . type larrow EXPR LETHELPER in EXPR

    type            shift and go to state 100


state 88

    (25) EXPR -> lparen EXPR rparen .

    at              reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    dot             reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    comma           reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    semi            reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    plus            reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    minus           reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    times           reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    divide          reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    lt              reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    le              reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    equals          reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    in              reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    rbrace          reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    then            reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    rparen          reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    of              reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    loop            reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    else            reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    pool            reduce using rule 25 (EXPR -> lparen EXPR rparen .)
    fi              reduce using rule 25 (EXPR -> lparen EXPR rparen .)


state 89

    (14) EXPR -> case EXPR of . CASEHELPER esac
    (15) CASEHELPER -> . identifier colon type rarrow EXPR semi
    (16) CASEHELPER -> . CASEHELPER identifier colon type rarrow EXPR semi
    (17) CASEHELPER -> .

  ! shift/reduce conflict for identifier resolved as shift
    identifier      shift and go to state 102
    esac            reduce using rule 17 (CASEHELPER -> .)

  ! identifier      [ reduce using rule 17 (CASEHELPER -> .) ]

    CASEHELPER                     shift and go to state 101

state 90

    (26) EXPR -> lbrace EXPR semi . rbrace
    (34) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    rbrace          shift and go to state 103
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 78

state 91

    (32) EXPR -> while EXPR loop . EXPR pool
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 104

state 92

    (27) EXPR -> identifier larrow EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    semi            reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    in              reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    rbrace          reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    then            reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    rparen          reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    of              reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    loop            reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    else            reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    pool            reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    fi              reduce using rule 27 (EXPR -> identifier larrow EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! at              [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! dot             [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! plus            [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! minus           [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! times           [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! divide          [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! lt              [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! le              [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! equals          [ reduce using rule 27 (EXPR -> identifier larrow EXPR .) ]
  ! comma           [ shift and go to state 60 ]
  ! semi            [ shift and go to state 54 ]


state 93

    (28) EXPR -> identifier lparen EXPR . rparen
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 105
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 94

    (50) EXPR -> identifier lparen rparen .

    at              reduce using rule 50 (EXPR -> identifier lparen rparen .)
    dot             reduce using rule 50 (EXPR -> identifier lparen rparen .)
    comma           reduce using rule 50 (EXPR -> identifier lparen rparen .)
    semi            reduce using rule 50 (EXPR -> identifier lparen rparen .)
    plus            reduce using rule 50 (EXPR -> identifier lparen rparen .)
    minus           reduce using rule 50 (EXPR -> identifier lparen rparen .)
    times           reduce using rule 50 (EXPR -> identifier lparen rparen .)
    divide          reduce using rule 50 (EXPR -> identifier lparen rparen .)
    lt              reduce using rule 50 (EXPR -> identifier lparen rparen .)
    le              reduce using rule 50 (EXPR -> identifier lparen rparen .)
    equals          reduce using rule 50 (EXPR -> identifier lparen rparen .)
    in              reduce using rule 50 (EXPR -> identifier lparen rparen .)
    rbrace          reduce using rule 50 (EXPR -> identifier lparen rparen .)
    then            reduce using rule 50 (EXPR -> identifier lparen rparen .)
    rparen          reduce using rule 50 (EXPR -> identifier lparen rparen .)
    of              reduce using rule 50 (EXPR -> identifier lparen rparen .)
    loop            reduce using rule 50 (EXPR -> identifier lparen rparen .)
    else            reduce using rule 50 (EXPR -> identifier lparen rparen .)
    pool            reduce using rule 50 (EXPR -> identifier lparen rparen .)
    fi              reduce using rule 50 (EXPR -> identifier lparen rparen .)


state 95

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace . EXPR rbrace
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 106

state 96

    (12) FORMAL -> FORMAL comma identifier colon type .

    rparen          reduce using rule 12 (FORMAL -> FORMAL comma identifier colon type .)
    comma           reduce using rule 12 (FORMAL -> FORMAL comma identifier colon type .)


state 97

    (31) EXPR -> if EXPR then EXPR . else EXPR fi
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    else            shift and go to state 107
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 98

    (21) EXPR -> EXPR at type dot . identifier lparen EXPR rparen
    (29) EXPR -> EXPR at type dot . identifier lparen rparen

    identifier      shift and go to state 108


state 99

    (22) EXPR -> EXPR dot identifier lparen . EXPR rparen
    (30) EXPR -> EXPR dot identifier lparen . rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    rparen          shift and go to state 110
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 109

state 100

    (23) EXPR -> let identifier colon type . LETHELPER in EXPR
    (24) EXPR -> let identifier colon type . larrow EXPR LETHELPER in EXPR
    (18) LETHELPER -> . comma identifier colon type LETHELPER
    (19) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (20) LETHELPER -> .

    larrow          shift and go to state 112
    comma           shift and go to state 111
    in              reduce using rule 20 (LETHELPER -> .)

    LETHELPER                      shift and go to state 113

state 101

    (14) EXPR -> case EXPR of CASEHELPER . esac
    (16) CASEHELPER -> CASEHELPER . identifier colon type rarrow EXPR semi

    esac            shift and go to state 114
    identifier      shift and go to state 115


state 102

    (15) CASEHELPER -> identifier . colon type rarrow EXPR semi

    colon           shift and go to state 116


state 103

    (26) EXPR -> lbrace EXPR semi rbrace .

    at              reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    dot             reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    comma           reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    semi            reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    plus            reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    minus           reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    times           reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    divide          reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    lt              reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    le              reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    equals          reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    in              reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    rbrace          reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    then            reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    rparen          reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    of              reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    loop            reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    else            reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    pool            reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)
    fi              reduce using rule 26 (EXPR -> lbrace EXPR semi rbrace .)


state 104

    (32) EXPR -> while EXPR loop EXPR . pool
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    pool            shift and go to state 117
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 105

    (28) EXPR -> identifier lparen EXPR rparen .

    at              reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    dot             reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    comma           reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    semi            reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    plus            reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    minus           reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    times           reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    divide          reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    lt              reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    le              reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    equals          reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    in              reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    rbrace          reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    then            reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    rparen          reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    of              reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    loop            reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    else            reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    pool            reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)
    fi              reduce using rule 28 (EXPR -> identifier lparen EXPR rparen .)


state 106

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR . rbrace
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 118
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 107

    (31) EXPR -> if EXPR then EXPR else . EXPR fi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 119

state 108

    (21) EXPR -> EXPR at type dot identifier . lparen EXPR rparen
    (29) EXPR -> EXPR at type dot identifier . lparen rparen

    lparen          shift and go to state 120


state 109

    (22) EXPR -> EXPR dot identifier lparen EXPR . rparen
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 121
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 110

    (30) EXPR -> EXPR dot identifier lparen rparen .

    at              reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    dot             reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    comma           reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    semi            reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    plus            reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    minus           reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    times           reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    divide          reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    lt              reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    le              reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    equals          reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    in              reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    rbrace          reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    then            reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    rparen          reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    of              reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    loop            reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    else            reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    pool            reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)
    fi              reduce using rule 30 (EXPR -> EXPR dot identifier lparen rparen .)


state 111

    (18) LETHELPER -> comma . identifier colon type LETHELPER
    (19) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER

    identifier      shift and go to state 122


state 112

    (24) EXPR -> let identifier colon type larrow . EXPR LETHELPER in EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 123

state 113

    (23) EXPR -> let identifier colon type LETHELPER . in EXPR

    in              shift and go to state 124


state 114

    (14) EXPR -> case EXPR of CASEHELPER esac .

    at              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    dot             reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    comma           reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    semi            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    plus            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    minus           reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    times           reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    divide          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    lt              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    le              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    equals          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    in              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    rbrace          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    then            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    rparen          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    of              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    loop            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    else            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    pool            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    fi              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)


state 115

    (16) CASEHELPER -> CASEHELPER identifier . colon type rarrow EXPR semi

    colon           shift and go to state 125


state 116

    (15) CASEHELPER -> identifier colon . type rarrow EXPR semi

    type            shift and go to state 126


state 117

    (32) EXPR -> while EXPR loop EXPR pool .

    at              reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    dot             reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    comma           reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    semi            reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    plus            reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    minus           reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    times           reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    divide          reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    lt              reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    le              reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    equals          reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    in              reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    rbrace          reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    then            reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    rparen          reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    of              reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    loop            reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    else            reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    pool            reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)
    fi              reduce using rule 32 (EXPR -> while EXPR loop EXPR pool .)


state 118

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 7 (FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .)
    rbrace          reduce using rule 7 (FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .)


state 119

    (31) EXPR -> if EXPR then EXPR else EXPR . fi
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    fi              shift and go to state 127
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 120

    (21) EXPR -> EXPR at type dot identifier lparen . EXPR rparen
    (29) EXPR -> EXPR at type dot identifier lparen . rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    rparen          shift and go to state 129
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 128

state 121

    (22) EXPR -> EXPR dot identifier lparen EXPR rparen .

    at              reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    dot             reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    comma           reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    semi            reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    plus            reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    minus           reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    times           reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    divide          reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    lt              reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    le              reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    equals          reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    in              reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    rbrace          reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    then            reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    of              reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    loop            reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    else            reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    pool            reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    fi              reduce using rule 22 (EXPR -> EXPR dot identifier lparen EXPR rparen .)


state 122

    (18) LETHELPER -> comma identifier . colon type LETHELPER
    (19) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER

    colon           shift and go to state 130


state 123

    (24) EXPR -> let identifier colon type larrow EXPR . LETHELPER in EXPR
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR
    (18) LETHELPER -> . comma identifier colon type LETHELPER
    (19) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (20) LETHELPER -> .

    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 131
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55
    in              reduce using rule 20 (LETHELPER -> .)

    LETHELPER                      shift and go to state 132

state 124

    (23) EXPR -> let identifier colon type LETHELPER in . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 133

state 125

    (16) CASEHELPER -> CASEHELPER identifier colon . type rarrow EXPR semi

    type            shift and go to state 134


state 126

    (15) CASEHELPER -> identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 135


state 127

    (31) EXPR -> if EXPR then EXPR else EXPR fi .

    at              reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    dot             reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    comma           reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    semi            reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    plus            reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    minus           reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    times           reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    divide          reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    lt              reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    le              reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    equals          reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    in              reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rbrace          reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    then            reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rparen          reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    of              reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    loop            reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    else            reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    pool            reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)
    fi              reduce using rule 31 (EXPR -> if EXPR then EXPR else EXPR fi .)


state 128

    (21) EXPR -> EXPR at type dot identifier lparen EXPR . rparen
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 136
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 129

    (29) EXPR -> EXPR at type dot identifier lparen rparen .

    at              reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    dot             reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    comma           reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    semi            reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    plus            reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    minus           reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    times           reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    divide          reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    lt              reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    le              reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    equals          reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    in              reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rbrace          reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    then            reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rparen          reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    of              reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    loop            reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    else            reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    pool            reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)
    fi              reduce using rule 29 (EXPR -> EXPR at type dot identifier lparen rparen .)


state 130

    (18) LETHELPER -> comma identifier colon . type LETHELPER
    (19) LETHELPER -> comma identifier colon . type larrow EXPR LETHELPER

    type            shift and go to state 137


state 131

    (33) EXPR -> EXPR comma . EXPR
    (18) LETHELPER -> comma . identifier colon type LETHELPER
    (19) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    identifier      shift and go to state 138
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 84

state 132

    (24) EXPR -> let identifier colon type larrow EXPR LETHELPER . in EXPR

    in              shift and go to state 139


state 133

    (23) EXPR -> let identifier colon type LETHELPER in EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    in              reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rbrace          reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    then            reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rparen          reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    of              reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    loop            reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    else            reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    pool            reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    fi              reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! at              [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 23 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]


state 134

    (16) CASEHELPER -> CASEHELPER identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 140


state 135

    (15) CASEHELPER -> identifier colon type rarrow . EXPR semi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 141

state 136

    (21) EXPR -> EXPR at type dot identifier lparen EXPR rparen .

    at              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    dot             reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    comma           reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    semi            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    plus            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    minus           reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    times           reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    divide          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    lt              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    le              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    equals          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    in              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    rbrace          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    then            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    of              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    loop            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    else            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    pool            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    fi              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)


state 137

    (18) LETHELPER -> comma identifier colon type . LETHELPER
    (19) LETHELPER -> comma identifier colon type . larrow EXPR LETHELPER
    (18) LETHELPER -> . comma identifier colon type LETHELPER
    (19) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (20) LETHELPER -> .

    larrow          shift and go to state 142
    comma           shift and go to state 111
    in              reduce using rule 20 (LETHELPER -> .)

    LETHELPER                      shift and go to state 143

state 138

    (18) LETHELPER -> comma identifier . colon type LETHELPER
    (19) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER
    (27) EXPR -> identifier . larrow EXPR
    (28) EXPR -> identifier . lparen EXPR rparen
    (45) EXPR -> identifier .
    (50) EXPR -> identifier . lparen rparen

    colon           shift and go to state 130
    larrow          shift and go to state 71
    lparen          shift and go to state 72
    at              reduce using rule 45 (EXPR -> identifier .)
    dot             reduce using rule 45 (EXPR -> identifier .)
    comma           reduce using rule 45 (EXPR -> identifier .)
    semi            reduce using rule 45 (EXPR -> identifier .)
    plus            reduce using rule 45 (EXPR -> identifier .)
    minus           reduce using rule 45 (EXPR -> identifier .)
    times           reduce using rule 45 (EXPR -> identifier .)
    divide          reduce using rule 45 (EXPR -> identifier .)
    lt              reduce using rule 45 (EXPR -> identifier .)
    le              reduce using rule 45 (EXPR -> identifier .)
    equals          reduce using rule 45 (EXPR -> identifier .)
    in              reduce using rule 45 (EXPR -> identifier .)


state 139

    (24) EXPR -> let identifier colon type larrow EXPR LETHELPER in . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 144

state 140

    (16) CASEHELPER -> CASEHELPER identifier colon type rarrow . EXPR semi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 145

state 141

    (15) CASEHELPER -> identifier colon type rarrow EXPR . semi
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 146
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 142

    (19) LETHELPER -> comma identifier colon type larrow . EXPR LETHELPER
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

    EXPR                           shift and go to state 147

state 143

    (18) LETHELPER -> comma identifier colon type LETHELPER .

    in              reduce using rule 18 (LETHELPER -> comma identifier colon type LETHELPER .)


state 144

    (24) EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    in              reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rbrace          reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    then            reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rparen          reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    of              reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    loop            reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    else            reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    pool            reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    fi              reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55

  ! at              [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 24 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]


state 145

    (16) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR . semi
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 148
    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 60
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55


state 146

    (15) CASEHELPER -> identifier colon type rarrow EXPR semi .
    (34) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 15 (CASEHELPER -> identifier colon type rarrow EXPR semi .)
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

  ! identifier      [ reduce using rule 15 (CASEHELPER -> identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 78

state 147

    (19) LETHELPER -> comma identifier colon type larrow EXPR . LETHELPER
    (21) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (22) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (29) EXPR -> EXPR . at type dot identifier lparen rparen
    (30) EXPR -> EXPR . dot identifier lparen rparen
    (33) EXPR -> EXPR . comma EXPR
    (34) EXPR -> EXPR . semi EXPR
    (38) EXPR -> EXPR . plus EXPR
    (39) EXPR -> EXPR . minus EXPR
    (40) EXPR -> EXPR . times EXPR
    (41) EXPR -> EXPR . divide EXPR
    (42) EXPR -> EXPR . lt EXPR
    (43) EXPR -> EXPR . le EXPR
    (44) EXPR -> EXPR . equals EXPR
    (18) LETHELPER -> . comma identifier colon type LETHELPER
    (19) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (20) LETHELPER -> .

    at              shift and go to state 59
    dot             shift and go to state 62
    comma           shift and go to state 131
    semi            shift and go to state 54
    plus            shift and go to state 52
    minus           shift and go to state 61
    times           shift and go to state 56
    divide          shift and go to state 53
    lt              shift and go to state 57
    le              shift and go to state 58
    equals          shift and go to state 55
    in              reduce using rule 20 (LETHELPER -> .)

    LETHELPER                      shift and go to state 149

state 148

    (16) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .
    (34) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (22) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (23) EXPR -> . let identifier colon type LETHELPER in EXPR
    (24) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (25) EXPR -> . lparen EXPR rparen
    (26) EXPR -> . lbrace EXPR semi rbrace
    (27) EXPR -> . identifier larrow EXPR
    (28) EXPR -> . identifier lparen EXPR rparen
    (29) EXPR -> . EXPR at type dot identifier lparen rparen
    (30) EXPR -> . EXPR dot identifier lparen rparen
    (31) EXPR -> . if EXPR then EXPR else EXPR fi
    (32) EXPR -> . while EXPR loop EXPR pool
    (33) EXPR -> . EXPR comma EXPR
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . isvoid EXPR
    (36) EXPR -> . tilde EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . EXPR plus EXPR
    (39) EXPR -> . EXPR minus EXPR
    (40) EXPR -> . EXPR times EXPR
    (41) EXPR -> . EXPR divide EXPR
    (42) EXPR -> . EXPR lt EXPR
    (43) EXPR -> . EXPR le EXPR
    (44) EXPR -> . EXPR equals EXPR
    (45) EXPR -> . identifier
    (46) EXPR -> . integer
    (47) EXPR -> . string
    (48) EXPR -> . true
    (49) EXPR -> . false
    (50) EXPR -> . identifier lparen rparen
    (51) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 16 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .)
    case            shift and go to state 43
    let             shift and go to state 38
    lparen          shift and go to state 39
    lbrace          shift and go to state 44
    identifier      shift and go to state 46
    if              shift and go to state 33
    while           shift and go to state 45
    isvoid          shift and go to state 36
    tilde           shift and go to state 32
    not             shift and go to state 41
    integer         shift and go to state 34
    string          shift and go to state 37
    true            shift and go to state 42
    false           shift and go to state 31
    new             shift and go to state 40

  ! identifier      [ reduce using rule 16 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 78

state 149

    (19) LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .

    in              reduce using rule 19 (LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for semi in state 21 resolved as shift
WARNING: shift/reduce conflict for at in state 78 resolved as shift
WARNING: shift/reduce conflict for dot in state 78 resolved as shift
WARNING: shift/reduce conflict for comma in state 78 resolved as shift
WARNING: shift/reduce conflict for semi in state 78 resolved as shift
WARNING: shift/reduce conflict for plus in state 78 resolved as shift
WARNING: shift/reduce conflict for minus in state 78 resolved as shift
WARNING: shift/reduce conflict for times in state 78 resolved as shift
WARNING: shift/reduce conflict for divide in state 78 resolved as shift
WARNING: shift/reduce conflict for lt in state 78 resolved as shift
WARNING: shift/reduce conflict for le in state 78 resolved as shift
WARNING: shift/reduce conflict for equals in state 78 resolved as shift
WARNING: shift/reduce conflict for at in state 84 resolved as shift
WARNING: shift/reduce conflict for dot in state 84 resolved as shift
WARNING: shift/reduce conflict for comma in state 84 resolved as shift
WARNING: shift/reduce conflict for semi in state 84 resolved as shift
WARNING: shift/reduce conflict for plus in state 84 resolved as shift
WARNING: shift/reduce conflict for minus in state 84 resolved as shift
WARNING: shift/reduce conflict for times in state 84 resolved as shift
WARNING: shift/reduce conflict for divide in state 84 resolved as shift
WARNING: shift/reduce conflict for lt in state 84 resolved as shift
WARNING: shift/reduce conflict for le in state 84 resolved as shift
WARNING: shift/reduce conflict for equals in state 84 resolved as shift
WARNING: shift/reduce conflict for identifier in state 89 resolved as shift
WARNING: shift/reduce conflict for at in state 133 resolved as shift
WARNING: shift/reduce conflict for dot in state 133 resolved as shift
WARNING: shift/reduce conflict for comma in state 133 resolved as shift
WARNING: shift/reduce conflict for semi in state 133 resolved as shift
WARNING: shift/reduce conflict for plus in state 133 resolved as shift
WARNING: shift/reduce conflict for minus in state 133 resolved as shift
WARNING: shift/reduce conflict for times in state 133 resolved as shift
WARNING: shift/reduce conflict for divide in state 133 resolved as shift
WARNING: shift/reduce conflict for lt in state 133 resolved as shift
WARNING: shift/reduce conflict for le in state 133 resolved as shift
WARNING: shift/reduce conflict for equals in state 133 resolved as shift
WARNING: shift/reduce conflict for at in state 144 resolved as shift
WARNING: shift/reduce conflict for dot in state 144 resolved as shift
WARNING: shift/reduce conflict for comma in state 144 resolved as shift
WARNING: shift/reduce conflict for semi in state 144 resolved as shift
WARNING: shift/reduce conflict for plus in state 144 resolved as shift
WARNING: shift/reduce conflict for minus in state 144 resolved as shift
WARNING: shift/reduce conflict for times in state 144 resolved as shift
WARNING: shift/reduce conflict for divide in state 144 resolved as shift
WARNING: shift/reduce conflict for lt in state 144 resolved as shift
WARNING: shift/reduce conflict for le in state 144 resolved as shift
WARNING: shift/reduce conflict for equals in state 144 resolved as shift
WARNING: shift/reduce conflict for identifier in state 146 resolved as shift
WARNING: shift/reduce conflict for identifier in state 148 resolved as shift
