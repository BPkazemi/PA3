Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> CLASSDEF semi
Rule 2     PROGRAM -> PROGRAM CLASSDEF semi
Rule 3     CLASSDEF -> class type lbrace rbrace
Rule 4     CLASSDEF -> class type lbrace FEATURE semi rbrace
Rule 5     CLASSDEF -> class type inherits type lbrace rbrace
Rule 6     CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace
Rule 7     FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
Rule 8     FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace
Rule 9     FEATURE -> identifier colon type
Rule 10    FEATURE -> identifier colon type larrow EXPR
Rule 11    FEATURE -> FEATURELIST semi FEATURE
Rule 12    FEATURELIST -> FEATURE semi FEATURELIST
Rule 13    FEATURELIST -> <empty>
Rule 14    FORMAL -> identifier colon type
Rule 15    FORMAL -> FORMAL comma identifier colon type
Rule 16    EXPR -> case EXPR of CASEHELPER esac
Rule 17    CASEHELPER -> identifier colon type rarrow EXPR semi
Rule 18    CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi
Rule 19    EXPR -> EXPR at type dot identifier lparen EXPR rparen
Rule 20    EXPR -> EXPR dot identifier lparen EXPR rparen
Rule 21    EXPR -> let identifier colon type LETHELPER in EXPR
Rule 22    EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR
Rule 23    LETHELPER -> comma identifier colon type LETHELPER
Rule 24    LETHELPER -> comma identifier colon type larrow EXPR LETHELPER
Rule 25    LETHELPER -> <empty>
Rule 26    EXPR -> lparen EXPR rparen
Rule 27    EXPR -> lbrace EXPR semi rbrace
Rule 28    EXPR -> identifier larrow EXPR
Rule 29    EXPR -> identifier lparen EXPR rparen
Rule 30    EXPR -> EXPR at type dot identifier lparen rparen
Rule 31    EXPR -> EXPR dot identifier lparen rparen
Rule 32    EXPR -> if EXPR then EXPR else EXPR fi
Rule 33    EXPR -> while EXPR loop EXPR pool
Rule 34    EXPR -> EXPR EXPRLISTCOMMA
Rule 35    EXPR -> EXPR EXPRLISTSEMI
Rule 36    EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA
Rule 37    EXPRLISTCOMMA -> comma EXPR
Rule 38    EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI
Rule 39    EXPRLISTSEMI -> semi EXPR
Rule 40    EXPR -> isvoid EXPR
Rule 41    EXPR -> tilde EXPR
Rule 42    EXPR -> not EXPR
Rule 43    EXPR -> EXPR plus EXPR
Rule 44    EXPR -> EXPR minus EXPR
Rule 45    EXPR -> EXPR times EXPR
Rule 46    EXPR -> EXPR divide EXPR
Rule 47    EXPR -> EXPR lt EXPR
Rule 48    EXPR -> EXPR le EXPR
Rule 49    EXPR -> EXPR equals EXPR
Rule 50    EXPR -> identifier
Rule 51    EXPR -> integer
Rule 52    EXPR -> string
Rule 53    EXPR -> true
Rule 54    EXPR -> false
Rule 55    EXPR -> identifier lparen rparen
Rule 56    EXPR -> new type

Terminals, with rules where they appear

at                   : 19 30
case                 : 16
class                : 3 4 5 6
colon                : 7 8 9 10 14 15 17 18 21 22 23 24
comma                : 15 23 24 36 37
divide               : 46
dot                  : 19 20 30 31
else                 : 32
equals               : 49
error                : 
esac                 : 16
false                : 54
fi                   : 32
identifier           : 7 8 9 10 14 15 17 18 19 20 21 22 23 24 28 29 30 31 50 55
if                   : 32
in                   : 21 22
inherits             : 5 6
integer              : 51
isvoid               : 40
larrow               : 10 22 24 28
lbrace               : 3 4 5 6 7 8 27
le                   : 48
let                  : 21 22
loop                 : 33
lparen               : 7 8 19 20 26 29 30 31 55
lt                   : 47
minus                : 44
new                  : 56
not                  : 42
of                   : 16
plus                 : 43
pool                 : 33
rarrow               : 17 18
rbrace               : 3 4 5 6 7 8 27
rparen               : 7 8 19 20 26 29 30 31 55
semi                 : 1 2 4 6 11 12 17 18 27 38 39
string               : 52
then                 : 32
tilde                : 41
times                : 45
true                 : 53
type                 : 3 4 5 5 6 6 7 8 9 10 14 15 17 18 19 21 22 23 24 30 56
while                : 33

Nonterminals, with rules where they appear

CASEHELPER           : 16 18
CLASSDEF             : 1 2
EXPR                 : 7 8 10 16 17 18 19 19 20 20 21 22 22 24 26 27 28 29 30 31 32 32 32 33 33 34 35 36 37 38 39 40 41 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49
EXPRLISTCOMMA        : 34 36
EXPRLISTSEMI         : 35 38
FEATURE              : 4 6 11 12
FEATURELIST          : 11 12
FORMAL               : 7 15
LETHELPER            : 21 22 23 24
PROGRAM              : 2 0

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . CLASSDEF semi
    (2) PROGRAM -> . PROGRAM CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 3

    PROGRAM                        shift and go to state 2
    CLASSDEF                       shift and go to state 1

state 1

    (1) PROGRAM -> CLASSDEF . semi

    semi            shift and go to state 4


state 2

    (0) S' -> PROGRAM .
    (2) PROGRAM -> PROGRAM . CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 3

    CLASSDEF                       shift and go to state 5

state 3

    (3) CLASSDEF -> class . type lbrace rbrace
    (4) CLASSDEF -> class . type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class . type inherits type lbrace rbrace
    (6) CLASSDEF -> class . type inherits type lbrace FEATURE semi rbrace

    type            shift and go to state 6


state 4

    (1) PROGRAM -> CLASSDEF semi .

    class           reduce using rule 1 (PROGRAM -> CLASSDEF semi .)
    $end            reduce using rule 1 (PROGRAM -> CLASSDEF semi .)


state 5

    (2) PROGRAM -> PROGRAM CLASSDEF . semi

    semi            shift and go to state 7


state 6

    (3) CLASSDEF -> class type . lbrace rbrace
    (4) CLASSDEF -> class type . lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class type . inherits type lbrace rbrace
    (6) CLASSDEF -> class type . inherits type lbrace FEATURE semi rbrace

    lbrace          shift and go to state 9
    inherits        shift and go to state 8


state 7

    (2) PROGRAM -> PROGRAM CLASSDEF semi .

    class           reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)
    $end            reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)


state 8

    (5) CLASSDEF -> class type inherits . type lbrace rbrace
    (6) CLASSDEF -> class type inherits . type lbrace FEATURE semi rbrace

    type            shift and go to state 10


state 9

    (3) CLASSDEF -> class type lbrace . rbrace
    (4) CLASSDEF -> class type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST semi FEATURE
    (12) FEATURELIST -> . FEATURE semi FEATURELIST
    (13) FEATURELIST -> .

    rbrace          shift and go to state 11
    identifier      shift and go to state 14
    semi            reduce using rule 13 (FEATURELIST -> .)

    FEATURELIST                    shift and go to state 13
    FEATURE                        shift and go to state 12

state 10

    (5) CLASSDEF -> class type inherits type . lbrace rbrace
    (6) CLASSDEF -> class type inherits type . lbrace FEATURE semi rbrace

    lbrace          shift and go to state 15


state 11

    (3) CLASSDEF -> class type lbrace rbrace .

    semi            reduce using rule 3 (CLASSDEF -> class type lbrace rbrace .)


state 12

    (4) CLASSDEF -> class type lbrace FEATURE . semi rbrace
    (12) FEATURELIST -> FEATURE . semi FEATURELIST

    semi            shift and go to state 16


state 13

    (11) FEATURE -> FEATURELIST . semi FEATURE

    semi            shift and go to state 17


state 14

    (7) FEATURE -> identifier . lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier . lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> identifier . colon type
    (10) FEATURE -> identifier . colon type larrow EXPR

    lparen          shift and go to state 19
    colon           shift and go to state 18


state 15

    (5) CLASSDEF -> class type inherits type lbrace . rbrace
    (6) CLASSDEF -> class type inherits type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST semi FEATURE
    (12) FEATURELIST -> . FEATURE semi FEATURELIST
    (13) FEATURELIST -> .

    rbrace          shift and go to state 20
    identifier      shift and go to state 14
    semi            reduce using rule 13 (FEATURELIST -> .)

    FEATURELIST                    shift and go to state 13
    FEATURE                        shift and go to state 21

state 16

    (4) CLASSDEF -> class type lbrace FEATURE semi . rbrace
    (12) FEATURELIST -> FEATURE semi . FEATURELIST
    (12) FEATURELIST -> . FEATURE semi FEATURELIST
    (13) FEATURELIST -> .
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST semi FEATURE

    rbrace          shift and go to state 22
    semi            reduce using rule 13 (FEATURELIST -> .)
    identifier      shift and go to state 14

    FEATURE                        shift and go to state 23
    FEATURELIST                    shift and go to state 24

state 17

    (11) FEATURE -> FEATURELIST semi . FEATURE
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST semi FEATURE
    (12) FEATURELIST -> . FEATURE semi FEATURELIST
    (13) FEATURELIST -> .

    identifier      shift and go to state 14
    semi            reduce using rule 13 (FEATURELIST -> .)

    FEATURELIST                    shift and go to state 13
    FEATURE                        shift and go to state 25

state 18

    (9) FEATURE -> identifier colon . type
    (10) FEATURE -> identifier colon . type larrow EXPR

    type            shift and go to state 26


state 19

    (7) FEATURE -> identifier lparen . FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier lparen . rparen colon type lbrace EXPR rbrace
    (14) FORMAL -> . identifier colon type
    (15) FORMAL -> . FORMAL comma identifier colon type

    rparen          shift and go to state 27
    identifier      shift and go to state 28

    FORMAL                         shift and go to state 29

state 20

    (5) CLASSDEF -> class type inherits type lbrace rbrace .

    semi            reduce using rule 5 (CLASSDEF -> class type inherits type lbrace rbrace .)


state 21

    (6) CLASSDEF -> class type inherits type lbrace FEATURE . semi rbrace
    (12) FEATURELIST -> FEATURE . semi FEATURELIST

    semi            shift and go to state 30


state 22

    (4) CLASSDEF -> class type lbrace FEATURE semi rbrace .

    semi            reduce using rule 4 (CLASSDEF -> class type lbrace FEATURE semi rbrace .)


state 23

    (12) FEATURELIST -> FEATURE . semi FEATURELIST

    semi            shift and go to state 31


state 24

    (12) FEATURELIST -> FEATURE semi FEATURELIST .
    (11) FEATURE -> FEATURELIST . semi FEATURE

  ! shift/reduce conflict for semi resolved as shift
    semi            shift and go to state 17

  ! semi            [ reduce using rule 12 (FEATURELIST -> FEATURE semi FEATURELIST .) ]


state 25

    (11) FEATURE -> FEATURELIST semi FEATURE .
    (12) FEATURELIST -> FEATURE . semi FEATURELIST

  ! shift/reduce conflict for semi resolved as shift
    semi            shift and go to state 31

  ! semi            [ reduce using rule 11 (FEATURE -> FEATURELIST semi FEATURE .) ]


state 26

    (9) FEATURE -> identifier colon type .
    (10) FEATURE -> identifier colon type . larrow EXPR

    semi            reduce using rule 9 (FEATURE -> identifier colon type .)
    larrow          shift and go to state 32


state 27

    (8) FEATURE -> identifier lparen rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 33


state 28

    (14) FORMAL -> identifier . colon type

    colon           shift and go to state 34


state 29

    (7) FEATURE -> identifier lparen FORMAL . rparen colon type lbrace EXPR rbrace
    (15) FORMAL -> FORMAL . comma identifier colon type

    rparen          shift and go to state 35
    comma           shift and go to state 36


state 30

    (6) CLASSDEF -> class type inherits type lbrace FEATURE semi . rbrace
    (12) FEATURELIST -> FEATURE semi . FEATURELIST
    (12) FEATURELIST -> . FEATURE semi FEATURELIST
    (13) FEATURELIST -> .
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST semi FEATURE

    rbrace          shift and go to state 37
    semi            reduce using rule 13 (FEATURELIST -> .)
    identifier      shift and go to state 14

    FEATURE                        shift and go to state 23
    FEATURELIST                    shift and go to state 24

state 31

    (12) FEATURELIST -> FEATURE semi . FEATURELIST
    (12) FEATURELIST -> . FEATURE semi FEATURELIST
    (13) FEATURELIST -> .
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST semi FEATURE

    semi            reduce using rule 13 (FEATURELIST -> .)
    identifier      shift and go to state 14

    FEATURE                        shift and go to state 23
    FEATURELIST                    shift and go to state 24

state 32

    (10) FEATURE -> identifier colon type larrow . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 42

state 33

    (8) FEATURE -> identifier lparen rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 54


state 34

    (14) FORMAL -> identifier colon . type

    type            shift and go to state 55


state 35

    (7) FEATURE -> identifier lparen FORMAL rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 56


state 36

    (15) FORMAL -> FORMAL comma . identifier colon type

    identifier      shift and go to state 57


state 37

    (6) CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .

    semi            reduce using rule 6 (CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .)


state 38

    (54) EXPR -> false .

    pool            reduce using rule 54 (EXPR -> false .)
    at              reduce using rule 54 (EXPR -> false .)
    dot             reduce using rule 54 (EXPR -> false .)
    plus            reduce using rule 54 (EXPR -> false .)
    minus           reduce using rule 54 (EXPR -> false .)
    times           reduce using rule 54 (EXPR -> false .)
    divide          reduce using rule 54 (EXPR -> false .)
    lt              reduce using rule 54 (EXPR -> false .)
    le              reduce using rule 54 (EXPR -> false .)
    equals          reduce using rule 54 (EXPR -> false .)
    comma           reduce using rule 54 (EXPR -> false .)
    semi            reduce using rule 54 (EXPR -> false .)
    then            reduce using rule 54 (EXPR -> false .)
    rparen          reduce using rule 54 (EXPR -> false .)
    of              reduce using rule 54 (EXPR -> false .)
    loop            reduce using rule 54 (EXPR -> false .)
    rbrace          reduce using rule 54 (EXPR -> false .)
    else            reduce using rule 54 (EXPR -> false .)
    fi              reduce using rule 54 (EXPR -> false .)
    in              reduce using rule 54 (EXPR -> false .)


state 39

    (41) EXPR -> tilde . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 58

state 40

    (32) EXPR -> if . EXPR then EXPR else EXPR fi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 59

state 41

    (51) EXPR -> integer .

    pool            reduce using rule 51 (EXPR -> integer .)
    at              reduce using rule 51 (EXPR -> integer .)
    dot             reduce using rule 51 (EXPR -> integer .)
    plus            reduce using rule 51 (EXPR -> integer .)
    minus           reduce using rule 51 (EXPR -> integer .)
    times           reduce using rule 51 (EXPR -> integer .)
    divide          reduce using rule 51 (EXPR -> integer .)
    lt              reduce using rule 51 (EXPR -> integer .)
    le              reduce using rule 51 (EXPR -> integer .)
    equals          reduce using rule 51 (EXPR -> integer .)
    comma           reduce using rule 51 (EXPR -> integer .)
    semi            reduce using rule 51 (EXPR -> integer .)
    then            reduce using rule 51 (EXPR -> integer .)
    rparen          reduce using rule 51 (EXPR -> integer .)
    of              reduce using rule 51 (EXPR -> integer .)
    loop            reduce using rule 51 (EXPR -> integer .)
    rbrace          reduce using rule 51 (EXPR -> integer .)
    else            reduce using rule 51 (EXPR -> integer .)
    fi              reduce using rule 51 (EXPR -> integer .)
    in              reduce using rule 51 (EXPR -> integer .)


state 42

    (10) FEATURE -> identifier colon type larrow EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    semi            reduce using rule 10 (FEATURE -> identifier colon type larrow EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65

  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 43

    (40) EXPR -> isvoid . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 73

state 44

    (52) EXPR -> string .

    pool            reduce using rule 52 (EXPR -> string .)
    at              reduce using rule 52 (EXPR -> string .)
    dot             reduce using rule 52 (EXPR -> string .)
    plus            reduce using rule 52 (EXPR -> string .)
    minus           reduce using rule 52 (EXPR -> string .)
    times           reduce using rule 52 (EXPR -> string .)
    divide          reduce using rule 52 (EXPR -> string .)
    lt              reduce using rule 52 (EXPR -> string .)
    le              reduce using rule 52 (EXPR -> string .)
    equals          reduce using rule 52 (EXPR -> string .)
    comma           reduce using rule 52 (EXPR -> string .)
    semi            reduce using rule 52 (EXPR -> string .)
    then            reduce using rule 52 (EXPR -> string .)
    rparen          reduce using rule 52 (EXPR -> string .)
    of              reduce using rule 52 (EXPR -> string .)
    loop            reduce using rule 52 (EXPR -> string .)
    rbrace          reduce using rule 52 (EXPR -> string .)
    else            reduce using rule 52 (EXPR -> string .)
    fi              reduce using rule 52 (EXPR -> string .)
    in              reduce using rule 52 (EXPR -> string .)


state 45

    (21) EXPR -> let . identifier colon type LETHELPER in EXPR
    (22) EXPR -> let . identifier colon type larrow EXPR LETHELPER in EXPR

    identifier      shift and go to state 74


state 46

    (26) EXPR -> lparen . EXPR rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 75

state 47

    (56) EXPR -> new . type

    type            shift and go to state 76


state 48

    (42) EXPR -> not . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 77

state 49

    (53) EXPR -> true .

    pool            reduce using rule 53 (EXPR -> true .)
    at              reduce using rule 53 (EXPR -> true .)
    dot             reduce using rule 53 (EXPR -> true .)
    plus            reduce using rule 53 (EXPR -> true .)
    minus           reduce using rule 53 (EXPR -> true .)
    times           reduce using rule 53 (EXPR -> true .)
    divide          reduce using rule 53 (EXPR -> true .)
    lt              reduce using rule 53 (EXPR -> true .)
    le              reduce using rule 53 (EXPR -> true .)
    equals          reduce using rule 53 (EXPR -> true .)
    comma           reduce using rule 53 (EXPR -> true .)
    semi            reduce using rule 53 (EXPR -> true .)
    then            reduce using rule 53 (EXPR -> true .)
    rparen          reduce using rule 53 (EXPR -> true .)
    of              reduce using rule 53 (EXPR -> true .)
    loop            reduce using rule 53 (EXPR -> true .)
    rbrace          reduce using rule 53 (EXPR -> true .)
    else            reduce using rule 53 (EXPR -> true .)
    fi              reduce using rule 53 (EXPR -> true .)
    in              reduce using rule 53 (EXPR -> true .)


state 50

    (16) EXPR -> case . EXPR of CASEHELPER esac
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 78

state 51

    (27) EXPR -> lbrace . EXPR semi rbrace
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 79

state 52

    (33) EXPR -> while . EXPR loop EXPR pool
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 80

state 53

    (28) EXPR -> identifier . larrow EXPR
    (29) EXPR -> identifier . lparen EXPR rparen
    (50) EXPR -> identifier .
    (55) EXPR -> identifier . lparen rparen

    larrow          shift and go to state 81
    lparen          shift and go to state 82
    pool            reduce using rule 50 (EXPR -> identifier .)
    at              reduce using rule 50 (EXPR -> identifier .)
    dot             reduce using rule 50 (EXPR -> identifier .)
    plus            reduce using rule 50 (EXPR -> identifier .)
    minus           reduce using rule 50 (EXPR -> identifier .)
    times           reduce using rule 50 (EXPR -> identifier .)
    divide          reduce using rule 50 (EXPR -> identifier .)
    lt              reduce using rule 50 (EXPR -> identifier .)
    le              reduce using rule 50 (EXPR -> identifier .)
    equals          reduce using rule 50 (EXPR -> identifier .)
    comma           reduce using rule 50 (EXPR -> identifier .)
    semi            reduce using rule 50 (EXPR -> identifier .)
    then            reduce using rule 50 (EXPR -> identifier .)
    rparen          reduce using rule 50 (EXPR -> identifier .)
    of              reduce using rule 50 (EXPR -> identifier .)
    loop            reduce using rule 50 (EXPR -> identifier .)
    rbrace          reduce using rule 50 (EXPR -> identifier .)
    else            reduce using rule 50 (EXPR -> identifier .)
    fi              reduce using rule 50 (EXPR -> identifier .)
    in              reduce using rule 50 (EXPR -> identifier .)


state 54

    (8) FEATURE -> identifier lparen rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 83


state 55

    (14) FORMAL -> identifier colon type .

    rparen          reduce using rule 14 (FORMAL -> identifier colon type .)
    comma           reduce using rule 14 (FORMAL -> identifier colon type .)


state 56

    (7) FEATURE -> identifier lparen FORMAL rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 84


state 57

    (15) FORMAL -> FORMAL comma identifier . colon type

    colon           shift and go to state 85


state 58

    (41) EXPR -> tilde EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 41 (EXPR -> tilde EXPR .)
    plus            reduce using rule 41 (EXPR -> tilde EXPR .)
    minus           reduce using rule 41 (EXPR -> tilde EXPR .)
    times           reduce using rule 41 (EXPR -> tilde EXPR .)
    divide          reduce using rule 41 (EXPR -> tilde EXPR .)
    lt              reduce using rule 41 (EXPR -> tilde EXPR .)
    le              reduce using rule 41 (EXPR -> tilde EXPR .)
    equals          reduce using rule 41 (EXPR -> tilde EXPR .)
    comma           reduce using rule 41 (EXPR -> tilde EXPR .)
    semi            reduce using rule 41 (EXPR -> tilde EXPR .)
    then            reduce using rule 41 (EXPR -> tilde EXPR .)
    rparen          reduce using rule 41 (EXPR -> tilde EXPR .)
    of              reduce using rule 41 (EXPR -> tilde EXPR .)
    loop            reduce using rule 41 (EXPR -> tilde EXPR .)
    rbrace          reduce using rule 41 (EXPR -> tilde EXPR .)
    else            reduce using rule 41 (EXPR -> tilde EXPR .)
    fi              reduce using rule 41 (EXPR -> tilde EXPR .)
    in              reduce using rule 41 (EXPR -> tilde EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71

  ! at              [ reduce using rule 41 (EXPR -> tilde EXPR .) ]
  ! dot             [ reduce using rule 41 (EXPR -> tilde EXPR .) ]
  ! plus            [ shift and go to state 69 ]
  ! minus           [ shift and go to state 70 ]
  ! times           [ shift and go to state 72 ]
  ! divide          [ shift and go to state 61 ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 59

    (32) EXPR -> if EXPR . then EXPR else EXPR fi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    then            shift and go to state 86
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 60

    (48) EXPR -> EXPR le . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 87

state 61

    (46) EXPR -> EXPR divide . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 88

state 62

    (38) EXPRLISTSEMI -> semi . EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 89

state 63

    (34) EXPR -> EXPR EXPRLISTCOMMA .

    pool            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    at              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    dot             reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    plus            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    minus           reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    times           reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    divide          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    lt              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    le              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    equals          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    comma           reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    semi            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    then            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    rparen          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    of              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    loop            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    rbrace          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    else            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    fi              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    in              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)


state 64

    (49) EXPR -> EXPR equals . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 90

state 65

    (36) EXPRLISTCOMMA -> comma . EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> comma . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 91

state 66

    (35) EXPR -> EXPR EXPRLISTSEMI .

    pool            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    at              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    dot             reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    plus            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    minus           reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    times           reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    divide          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    lt              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    le              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    equals          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    comma           reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    semi            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    then            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    rparen          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    of              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    loop            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    rbrace          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    else            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    fi              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    in              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)


state 67

    (47) EXPR -> EXPR lt . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 92

state 68

    (19) EXPR -> EXPR at . type dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR at . type dot identifier lparen rparen

    type            shift and go to state 93


state 69

    (43) EXPR -> EXPR plus . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 94

state 70

    (44) EXPR -> EXPR minus . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 95

state 71

    (20) EXPR -> EXPR dot . identifier lparen EXPR rparen
    (31) EXPR -> EXPR dot . identifier lparen rparen

    identifier      shift and go to state 96


state 72

    (45) EXPR -> EXPR times . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 97

state 73

    (40) EXPR -> isvoid EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 40 (EXPR -> isvoid EXPR .)
    plus            reduce using rule 40 (EXPR -> isvoid EXPR .)
    minus           reduce using rule 40 (EXPR -> isvoid EXPR .)
    times           reduce using rule 40 (EXPR -> isvoid EXPR .)
    divide          reduce using rule 40 (EXPR -> isvoid EXPR .)
    lt              reduce using rule 40 (EXPR -> isvoid EXPR .)
    le              reduce using rule 40 (EXPR -> isvoid EXPR .)
    equals          reduce using rule 40 (EXPR -> isvoid EXPR .)
    comma           reduce using rule 40 (EXPR -> isvoid EXPR .)
    semi            reduce using rule 40 (EXPR -> isvoid EXPR .)
    then            reduce using rule 40 (EXPR -> isvoid EXPR .)
    rparen          reduce using rule 40 (EXPR -> isvoid EXPR .)
    of              reduce using rule 40 (EXPR -> isvoid EXPR .)
    loop            reduce using rule 40 (EXPR -> isvoid EXPR .)
    rbrace          reduce using rule 40 (EXPR -> isvoid EXPR .)
    else            reduce using rule 40 (EXPR -> isvoid EXPR .)
    fi              reduce using rule 40 (EXPR -> isvoid EXPR .)
    in              reduce using rule 40 (EXPR -> isvoid EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71

  ! at              [ reduce using rule 40 (EXPR -> isvoid EXPR .) ]
  ! dot             [ reduce using rule 40 (EXPR -> isvoid EXPR .) ]
  ! plus            [ shift and go to state 69 ]
  ! minus           [ shift and go to state 70 ]
  ! times           [ shift and go to state 72 ]
  ! divide          [ shift and go to state 61 ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 74

    (21) EXPR -> let identifier . colon type LETHELPER in EXPR
    (22) EXPR -> let identifier . colon type larrow EXPR LETHELPER in EXPR

    colon           shift and go to state 98


state 75

    (26) EXPR -> lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    rparen          shift and go to state 99
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 76

    (56) EXPR -> new type .

    pool            reduce using rule 56 (EXPR -> new type .)
    at              reduce using rule 56 (EXPR -> new type .)
    dot             reduce using rule 56 (EXPR -> new type .)
    plus            reduce using rule 56 (EXPR -> new type .)
    minus           reduce using rule 56 (EXPR -> new type .)
    times           reduce using rule 56 (EXPR -> new type .)
    divide          reduce using rule 56 (EXPR -> new type .)
    lt              reduce using rule 56 (EXPR -> new type .)
    le              reduce using rule 56 (EXPR -> new type .)
    equals          reduce using rule 56 (EXPR -> new type .)
    comma           reduce using rule 56 (EXPR -> new type .)
    semi            reduce using rule 56 (EXPR -> new type .)
    then            reduce using rule 56 (EXPR -> new type .)
    rparen          reduce using rule 56 (EXPR -> new type .)
    of              reduce using rule 56 (EXPR -> new type .)
    loop            reduce using rule 56 (EXPR -> new type .)
    rbrace          reduce using rule 56 (EXPR -> new type .)
    else            reduce using rule 56 (EXPR -> new type .)
    fi              reduce using rule 56 (EXPR -> new type .)
    in              reduce using rule 56 (EXPR -> new type .)


state 77

    (42) EXPR -> not EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 42 (EXPR -> not EXPR .)
    comma           reduce using rule 42 (EXPR -> not EXPR .)
    semi            reduce using rule 42 (EXPR -> not EXPR .)
    then            reduce using rule 42 (EXPR -> not EXPR .)
    rparen          reduce using rule 42 (EXPR -> not EXPR .)
    of              reduce using rule 42 (EXPR -> not EXPR .)
    loop            reduce using rule 42 (EXPR -> not EXPR .)
    rbrace          reduce using rule 42 (EXPR -> not EXPR .)
    else            reduce using rule 42 (EXPR -> not EXPR .)
    fi              reduce using rule 42 (EXPR -> not EXPR .)
    in              reduce using rule 42 (EXPR -> not EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64

  ! at              [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! dot             [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! plus            [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! minus           [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! times           [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! divide          [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! lt              [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! le              [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! equals          [ reduce using rule 42 (EXPR -> not EXPR .) ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 78

    (16) EXPR -> case EXPR . of CASEHELPER esac
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    of              shift and go to state 100
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 79

    (27) EXPR -> lbrace EXPR . semi rbrace
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    semi            shift and go to state 101
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 80

    (33) EXPR -> while EXPR . loop EXPR pool
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    loop            shift and go to state 102
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 81

    (28) EXPR -> identifier larrow . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 103

state 82

    (29) EXPR -> identifier lparen . EXPR rparen
    (55) EXPR -> identifier lparen . rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    rparen          shift and go to state 105
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 104

state 83

    (8) FEATURE -> identifier lparen rparen colon type lbrace . EXPR rbrace
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 106

state 84

    (7) FEATURE -> identifier lparen FORMAL rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 107


state 85

    (15) FORMAL -> FORMAL comma identifier colon . type

    type            shift and go to state 108


state 86

    (32) EXPR -> if EXPR then . EXPR else EXPR fi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 109

state 87

    (48) EXPR -> EXPR le EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 48 (EXPR -> EXPR le EXPR .)
    lt              reduce using rule 48 (EXPR -> EXPR le EXPR .)
    le              reduce using rule 48 (EXPR -> EXPR le EXPR .)
    equals          reduce using rule 48 (EXPR -> EXPR le EXPR .)
    comma           reduce using rule 48 (EXPR -> EXPR le EXPR .)
    semi            reduce using rule 48 (EXPR -> EXPR le EXPR .)
    then            reduce using rule 48 (EXPR -> EXPR le EXPR .)
    rparen          reduce using rule 48 (EXPR -> EXPR le EXPR .)
    of              reduce using rule 48 (EXPR -> EXPR le EXPR .)
    loop            reduce using rule 48 (EXPR -> EXPR le EXPR .)
    rbrace          reduce using rule 48 (EXPR -> EXPR le EXPR .)
    else            reduce using rule 48 (EXPR -> EXPR le EXPR .)
    fi              reduce using rule 48 (EXPR -> EXPR le EXPR .)
    in              reduce using rule 48 (EXPR -> EXPR le EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61

  ! at              [ reduce using rule 48 (EXPR -> EXPR le EXPR .) ]
  ! dot             [ reduce using rule 48 (EXPR -> EXPR le EXPR .) ]
  ! plus            [ reduce using rule 48 (EXPR -> EXPR le EXPR .) ]
  ! minus           [ reduce using rule 48 (EXPR -> EXPR le EXPR .) ]
  ! times           [ reduce using rule 48 (EXPR -> EXPR le EXPR .) ]
  ! divide          [ reduce using rule 48 (EXPR -> EXPR le EXPR .) ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 88

    (46) EXPR -> EXPR divide EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    plus            reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    lt              reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    le              reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    comma           reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    semi            reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    then            reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    rparen          reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    of              reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    loop            reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    rbrace          reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    fi              reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    in              reduce using rule 46 (EXPR -> EXPR divide EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71

  ! at              [ reduce using rule 46 (EXPR -> EXPR divide EXPR .) ]
  ! dot             [ reduce using rule 46 (EXPR -> EXPR divide EXPR .) ]
  ! plus            [ shift and go to state 69 ]
  ! minus           [ shift and go to state 70 ]
  ! times           [ shift and go to state 72 ]
  ! divide          [ shift and go to state 61 ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 89

    (38) EXPRLISTSEMI -> semi EXPR . EXPRLISTSEMI
    (39) EXPRLISTSEMI -> semi EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for comma resolved as shift
    then            reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    rparen          reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    of              reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    loop            reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    rbrace          reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    else            reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    pool            reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    fi              reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    in              reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    semi            shift and go to state 62
    comma           shift and go to state 65

  ! at              [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! dot             [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! plus            [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! minus           [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! times           [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! divide          [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! lt              [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! le              [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! equals          [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! comma           [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]
  ! semi            [ reduce using rule 39 (EXPRLISTSEMI -> semi EXPR .) ]

    EXPRLISTCOMMA                  shift and go to state 63
    EXPRLISTSEMI                   shift and go to state 110

state 90

    (49) EXPR -> EXPR equals EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    lt              reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    le              reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    equals          reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    comma           reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    semi            reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    then            reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    rparen          reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    of              reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    loop            reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    rbrace          reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    else            reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    fi              reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    in              reduce using rule 49 (EXPR -> EXPR equals EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61

  ! at              [ reduce using rule 49 (EXPR -> EXPR equals EXPR .) ]
  ! dot             [ reduce using rule 49 (EXPR -> EXPR equals EXPR .) ]
  ! plus            [ reduce using rule 49 (EXPR -> EXPR equals EXPR .) ]
  ! minus           [ reduce using rule 49 (EXPR -> EXPR equals EXPR .) ]
  ! times           [ reduce using rule 49 (EXPR -> EXPR equals EXPR .) ]
  ! divide          [ reduce using rule 49 (EXPR -> EXPR equals EXPR .) ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 91

    (36) EXPRLISTCOMMA -> comma EXPR . EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> comma EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
    rparen          reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    fi              reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    in              reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    loop            reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    then            reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    of              reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    rbrace          reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    else            reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    pool            reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

  ! at              [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! dot             [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! plus            [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! minus           [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! times           [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! divide          [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! lt              [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! le              [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! equals          [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! comma           [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]
  ! semi            [ reduce using rule 37 (EXPRLISTCOMMA -> comma EXPR .) ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 111

state 92

    (47) EXPR -> EXPR lt EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    lt              reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    le              reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    equals          reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    comma           reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    semi            reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    then            reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    rparen          reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    of              reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    loop            reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    rbrace          reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    else            reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    fi              reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    in              reduce using rule 47 (EXPR -> EXPR lt EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61

  ! at              [ reduce using rule 47 (EXPR -> EXPR lt EXPR .) ]
  ! dot             [ reduce using rule 47 (EXPR -> EXPR lt EXPR .) ]
  ! plus            [ reduce using rule 47 (EXPR -> EXPR lt EXPR .) ]
  ! minus           [ reduce using rule 47 (EXPR -> EXPR lt EXPR .) ]
  ! times           [ reduce using rule 47 (EXPR -> EXPR lt EXPR .) ]
  ! divide          [ reduce using rule 47 (EXPR -> EXPR lt EXPR .) ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 93

    (19) EXPR -> EXPR at type . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR at type . dot identifier lparen rparen

    dot             shift and go to state 112


state 94

    (43) EXPR -> EXPR plus EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    plus            reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    lt              reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    le              reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    comma           reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    semi            reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    then            reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    rparen          reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    of              reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    loop            reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    rbrace          reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    fi              reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    in              reduce using rule 43 (EXPR -> EXPR plus EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    times           shift and go to state 72
    divide          shift and go to state 61

  ! at              [ reduce using rule 43 (EXPR -> EXPR plus EXPR .) ]
  ! dot             [ reduce using rule 43 (EXPR -> EXPR plus EXPR .) ]
  ! times           [ reduce using rule 43 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 43 (EXPR -> EXPR plus EXPR .) ]
  ! plus            [ shift and go to state 69 ]
  ! minus           [ shift and go to state 70 ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 95

    (44) EXPR -> EXPR minus EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    plus            reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    lt              reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    le              reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    comma           reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    semi            reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    then            reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    rparen          reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    of              reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    loop            reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    rbrace          reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    fi              reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    in              reduce using rule 44 (EXPR -> EXPR minus EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    times           shift and go to state 72
    divide          shift and go to state 61

  ! at              [ reduce using rule 44 (EXPR -> EXPR minus EXPR .) ]
  ! dot             [ reduce using rule 44 (EXPR -> EXPR minus EXPR .) ]
  ! times           [ reduce using rule 44 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 44 (EXPR -> EXPR minus EXPR .) ]
  ! plus            [ shift and go to state 69 ]
  ! minus           [ shift and go to state 70 ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 96

    (20) EXPR -> EXPR dot identifier . lparen EXPR rparen
    (31) EXPR -> EXPR dot identifier . lparen rparen

    lparen          shift and go to state 113


state 97

    (45) EXPR -> EXPR times EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 45 (EXPR -> EXPR times EXPR .)
    plus            reduce using rule 45 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 45 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 45 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 45 (EXPR -> EXPR times EXPR .)
    lt              reduce using rule 45 (EXPR -> EXPR times EXPR .)
    le              reduce using rule 45 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 45 (EXPR -> EXPR times EXPR .)
    comma           reduce using rule 45 (EXPR -> EXPR times EXPR .)
    semi            reduce using rule 45 (EXPR -> EXPR times EXPR .)
    then            reduce using rule 45 (EXPR -> EXPR times EXPR .)
    rparen          reduce using rule 45 (EXPR -> EXPR times EXPR .)
    of              reduce using rule 45 (EXPR -> EXPR times EXPR .)
    loop            reduce using rule 45 (EXPR -> EXPR times EXPR .)
    rbrace          reduce using rule 45 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 45 (EXPR -> EXPR times EXPR .)
    fi              reduce using rule 45 (EXPR -> EXPR times EXPR .)
    in              reduce using rule 45 (EXPR -> EXPR times EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71

  ! at              [ reduce using rule 45 (EXPR -> EXPR times EXPR .) ]
  ! dot             [ reduce using rule 45 (EXPR -> EXPR times EXPR .) ]
  ! plus            [ shift and go to state 69 ]
  ! minus           [ shift and go to state 70 ]
  ! times           [ shift and go to state 72 ]
  ! divide          [ shift and go to state 61 ]
  ! lt              [ shift and go to state 67 ]
  ! le              [ shift and go to state 60 ]
  ! equals          [ shift and go to state 64 ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 98

    (21) EXPR -> let identifier colon . type LETHELPER in EXPR
    (22) EXPR -> let identifier colon . type larrow EXPR LETHELPER in EXPR

    type            shift and go to state 114


state 99

    (26) EXPR -> lparen EXPR rparen .

    pool            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    at              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    dot             reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    plus            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    minus           reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    times           reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    divide          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    lt              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    le              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    equals          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    comma           reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    semi            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    then            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    rparen          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    of              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    loop            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    rbrace          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    else            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    fi              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    in              reduce using rule 26 (EXPR -> lparen EXPR rparen .)


state 100

    (16) EXPR -> case EXPR of . CASEHELPER esac
    (17) CASEHELPER -> . identifier colon type rarrow EXPR semi
    (18) CASEHELPER -> . CASEHELPER identifier colon type rarrow EXPR semi

    identifier      shift and go to state 116

    CASEHELPER                     shift and go to state 115

state 101

    (27) EXPR -> lbrace EXPR semi . rbrace
    (38) EXPRLISTSEMI -> semi . EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    rbrace          shift and go to state 117
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 89

state 102

    (33) EXPR -> while EXPR loop . EXPR pool
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 118

state 103

    (28) EXPR -> identifier larrow EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    comma           reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    semi            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    then            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    rparen          reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    of              reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    loop            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    rbrace          reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    else            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    fi              reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    in              reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64

  ! at              [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! dot             [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! plus            [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! minus           [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! times           [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! divide          [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! lt              [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! le              [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! equals          [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! comma           [ shift and go to state 65 ]
  ! semi            [ shift and go to state 62 ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 104

    (29) EXPR -> identifier lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    rparen          shift and go to state 119
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 105

    (55) EXPR -> identifier lparen rparen .

    pool            reduce using rule 55 (EXPR -> identifier lparen rparen .)
    at              reduce using rule 55 (EXPR -> identifier lparen rparen .)
    dot             reduce using rule 55 (EXPR -> identifier lparen rparen .)
    plus            reduce using rule 55 (EXPR -> identifier lparen rparen .)
    minus           reduce using rule 55 (EXPR -> identifier lparen rparen .)
    times           reduce using rule 55 (EXPR -> identifier lparen rparen .)
    divide          reduce using rule 55 (EXPR -> identifier lparen rparen .)
    lt              reduce using rule 55 (EXPR -> identifier lparen rparen .)
    le              reduce using rule 55 (EXPR -> identifier lparen rparen .)
    equals          reduce using rule 55 (EXPR -> identifier lparen rparen .)
    comma           reduce using rule 55 (EXPR -> identifier lparen rparen .)
    semi            reduce using rule 55 (EXPR -> identifier lparen rparen .)
    then            reduce using rule 55 (EXPR -> identifier lparen rparen .)
    rparen          reduce using rule 55 (EXPR -> identifier lparen rparen .)
    of              reduce using rule 55 (EXPR -> identifier lparen rparen .)
    loop            reduce using rule 55 (EXPR -> identifier lparen rparen .)
    rbrace          reduce using rule 55 (EXPR -> identifier lparen rparen .)
    else            reduce using rule 55 (EXPR -> identifier lparen rparen .)
    fi              reduce using rule 55 (EXPR -> identifier lparen rparen .)
    in              reduce using rule 55 (EXPR -> identifier lparen rparen .)


state 106

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR . rbrace
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    rbrace          shift and go to state 120
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 107

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace . EXPR rbrace
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 121

state 108

    (15) FORMAL -> FORMAL comma identifier colon type .

    rparen          reduce using rule 15 (FORMAL -> FORMAL comma identifier colon type .)
    comma           reduce using rule 15 (FORMAL -> FORMAL comma identifier colon type .)


state 109

    (32) EXPR -> if EXPR then EXPR . else EXPR fi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    else            shift and go to state 122
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 110

    (38) EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .
    (35) EXPR -> EXPR EXPRLISTSEMI .

  ! reduce/reduce conflict for at resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for dot resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for plus resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for minus resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for times resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for divide resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for lt resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for le resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for equals resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for semi resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for comma resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for then resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for rparen resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for of resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for loop resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for rbrace resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for else resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for pool resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for fi resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
  ! reduce/reduce conflict for in resolved using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    at              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    dot             reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    plus            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    minus           reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    times           reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    divide          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    lt              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    le              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    equals          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    semi            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    comma           reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    then            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    rparen          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    of              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    loop            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    rbrace          reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    else            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    pool            reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    fi              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)
    in              reduce using rule 35 (EXPR -> EXPR EXPRLISTSEMI .)

  ! at              [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! dot             [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! plus            [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! minus           [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! times           [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! divide          [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! lt              [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! le              [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! equals          [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! comma           [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! semi            [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! then            [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! rparen          [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! of              [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! loop            [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! rbrace          [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! else            [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! pool            [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! fi              [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]
  ! in              [ reduce using rule 38 (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI .) ]


state 111

    (36) EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .
    (34) EXPR -> EXPR EXPRLISTCOMMA .

  ! reduce/reduce conflict for at resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for dot resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for plus resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for minus resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for times resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for divide resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for lt resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for le resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for equals resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for comma resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for semi resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for then resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for rparen resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for of resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for loop resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for rbrace resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for else resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for pool resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for fi resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
  ! reduce/reduce conflict for in resolved using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    at              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    dot             reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    plus            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    minus           reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    times           reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    divide          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    lt              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    le              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    equals          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    comma           reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    semi            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    then            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    rparen          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    of              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    loop            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    rbrace          reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    else            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    pool            reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    fi              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)
    in              reduce using rule 34 (EXPR -> EXPR EXPRLISTCOMMA .)

  ! rparen          [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! at              [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! dot             [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! plus            [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! minus           [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! times           [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! divide          [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! lt              [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! le              [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! equals          [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! comma           [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! semi            [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! fi              [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! in              [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! loop            [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! then            [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! of              [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! rbrace          [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! else            [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]
  ! pool            [ reduce using rule 36 (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA .) ]


state 112

    (19) EXPR -> EXPR at type dot . identifier lparen EXPR rparen
    (30) EXPR -> EXPR at type dot . identifier lparen rparen

    identifier      shift and go to state 123


state 113

    (20) EXPR -> EXPR dot identifier lparen . EXPR rparen
    (31) EXPR -> EXPR dot identifier lparen . rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    rparen          shift and go to state 125
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 124

state 114

    (21) EXPR -> let identifier colon type . LETHELPER in EXPR
    (22) EXPR -> let identifier colon type . larrow EXPR LETHELPER in EXPR
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .

    larrow          shift and go to state 127
    comma           shift and go to state 126
    in              reduce using rule 25 (LETHELPER -> .)

    LETHELPER                      shift and go to state 128

state 115

    (16) EXPR -> case EXPR of CASEHELPER . esac
    (18) CASEHELPER -> CASEHELPER . identifier colon type rarrow EXPR semi

    esac            shift and go to state 129
    identifier      shift and go to state 130


state 116

    (17) CASEHELPER -> identifier . colon type rarrow EXPR semi

    colon           shift and go to state 131


state 117

    (27) EXPR -> lbrace EXPR semi rbrace .

    pool            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    at              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    dot             reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    plus            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    minus           reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    times           reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    divide          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    lt              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    le              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    equals          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    comma           reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    semi            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    then            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    rparen          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    of              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    loop            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    rbrace          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    else            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    fi              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    in              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)


state 118

    (33) EXPR -> while EXPR loop EXPR . pool
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    pool            shift and go to state 132
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 119

    (29) EXPR -> identifier lparen EXPR rparen .

    pool            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    at              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    dot             reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    plus            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    minus           reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    times           reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    divide          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    lt              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    le              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    equals          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    comma           reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    semi            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    then            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    rparen          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    of              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    loop            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    rbrace          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    else            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    fi              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    in              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)


state 120

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 8 (FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .)


state 121

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR . rbrace
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    rbrace          shift and go to state 133
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTCOMMA                  shift and go to state 63
    EXPRLISTSEMI                   shift and go to state 66

state 122

    (32) EXPR -> if EXPR then EXPR else . EXPR fi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 134

state 123

    (19) EXPR -> EXPR at type dot identifier . lparen EXPR rparen
    (30) EXPR -> EXPR at type dot identifier . lparen rparen

    lparen          shift and go to state 135


state 124

    (20) EXPR -> EXPR dot identifier lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    rparen          shift and go to state 136
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 125

    (31) EXPR -> EXPR dot identifier lparen rparen .

    pool            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    at              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    dot             reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    plus            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    minus           reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    times           reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    divide          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    lt              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    le              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    equals          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    comma           reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    semi            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    then            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    rparen          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    of              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    loop            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    rbrace          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    else            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    fi              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    in              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)


state 126

    (23) LETHELPER -> comma . identifier colon type LETHELPER
    (24) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER

    identifier      shift and go to state 137


state 127

    (22) EXPR -> let identifier colon type larrow . EXPR LETHELPER in EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 138

state 128

    (21) EXPR -> let identifier colon type LETHELPER . in EXPR

    in              shift and go to state 139


state 129

    (16) EXPR -> case EXPR of CASEHELPER esac .

    pool            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    at              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    dot             reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    plus            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    minus           reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    times           reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    divide          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    lt              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    le              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    equals          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    comma           reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    semi            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    then            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    rparen          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    of              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    loop            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    rbrace          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    else            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    fi              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    in              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)


state 130

    (18) CASEHELPER -> CASEHELPER identifier . colon type rarrow EXPR semi

    colon           shift and go to state 140


state 131

    (17) CASEHELPER -> identifier colon . type rarrow EXPR semi

    type            shift and go to state 141


state 132

    (33) EXPR -> while EXPR loop EXPR pool .

    pool            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    at              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    dot             reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    plus            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    minus           reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    times           reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    divide          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    lt              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    le              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    equals          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    comma           reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    semi            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    then            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    rparen          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    of              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    loop            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    rbrace          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    else            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    fi              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    in              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)


state 133

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 7 (FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .)


state 134

    (32) EXPR -> if EXPR then EXPR else EXPR . fi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    fi              shift and go to state 142
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 135

    (19) EXPR -> EXPR at type dot identifier lparen . EXPR rparen
    (30) EXPR -> EXPR at type dot identifier lparen . rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    rparen          shift and go to state 144
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 143

state 136

    (20) EXPR -> EXPR dot identifier lparen EXPR rparen .

    pool            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    at              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    dot             reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    plus            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    minus           reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    times           reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    divide          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    lt              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    le              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    equals          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    comma           reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    semi            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    then            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    of              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    loop            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    rbrace          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    else            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    fi              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    in              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)


state 137

    (23) LETHELPER -> comma identifier . colon type LETHELPER
    (24) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER

    colon           shift and go to state 145


state 138

    (22) EXPR -> let identifier colon type larrow EXPR . LETHELPER in EXPR
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 146
    in              reduce using rule 25 (LETHELPER -> .)
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    LETHELPER                      shift and go to state 147
    EXPRLISTCOMMA                  shift and go to state 63

state 139

    (21) EXPR -> let identifier colon type LETHELPER in . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 148

state 140

    (18) CASEHELPER -> CASEHELPER identifier colon . type rarrow EXPR semi

    type            shift and go to state 149


state 141

    (17) CASEHELPER -> identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 150


state 142

    (32) EXPR -> if EXPR then EXPR else EXPR fi .

    pool            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    at              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    dot             reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    plus            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    minus           reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    times           reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    divide          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    lt              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    le              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    equals          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    comma           reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    semi            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    then            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rparen          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    of              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    loop            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rbrace          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    else            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    fi              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    in              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)


state 143

    (19) EXPR -> EXPR at type dot identifier lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    rparen          shift and go to state 151
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 144

    (30) EXPR -> EXPR at type dot identifier lparen rparen .

    pool            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    at              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    dot             reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    plus            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    minus           reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    times           reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    divide          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    lt              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    le              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    equals          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    comma           reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    semi            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    then            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rparen          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    of              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    loop            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rbrace          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    else            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    fi              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    in              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)


state 145

    (23) LETHELPER -> comma identifier colon . type LETHELPER
    (24) LETHELPER -> comma identifier colon . type larrow EXPR LETHELPER

    type            shift and go to state 152


state 146

    (23) LETHELPER -> comma . identifier colon type LETHELPER
    (24) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER
    (36) EXPRLISTCOMMA -> comma . EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> comma . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    identifier      shift and go to state 153
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 91

state 147

    (22) EXPR -> let identifier colon type larrow EXPR LETHELPER . in EXPR

    in              shift and go to state 154


state 148

    (21) EXPR -> let identifier colon type LETHELPER in EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
    pool            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    then            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rparen          reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    of              reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    loop            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rbrace          reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    else            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    fi              reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    in              reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

  ! at              [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 149

    (18) CASEHELPER -> CASEHELPER identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 155


state 150

    (17) CASEHELPER -> identifier colon type rarrow . EXPR semi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 156

state 151

    (19) EXPR -> EXPR at type dot identifier lparen EXPR rparen .

    pool            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    at              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    dot             reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    plus            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    minus           reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    times           reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    divide          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    lt              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    le              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    equals          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    comma           reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    semi            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    then            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    of              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    loop            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    rbrace          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    else            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    fi              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    in              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)


state 152

    (23) LETHELPER -> comma identifier colon type . LETHELPER
    (24) LETHELPER -> comma identifier colon type . larrow EXPR LETHELPER
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .

    larrow          shift and go to state 157
    comma           shift and go to state 126
    in              reduce using rule 25 (LETHELPER -> .)

    LETHELPER                      shift and go to state 158

state 153

    (23) LETHELPER -> comma identifier . colon type LETHELPER
    (24) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER
    (28) EXPR -> identifier . larrow EXPR
    (29) EXPR -> identifier . lparen EXPR rparen
    (50) EXPR -> identifier .
    (55) EXPR -> identifier . lparen rparen

    colon           shift and go to state 145
    larrow          shift and go to state 81
    lparen          shift and go to state 82
    at              reduce using rule 50 (EXPR -> identifier .)
    dot             reduce using rule 50 (EXPR -> identifier .)
    plus            reduce using rule 50 (EXPR -> identifier .)
    minus           reduce using rule 50 (EXPR -> identifier .)
    times           reduce using rule 50 (EXPR -> identifier .)
    divide          reduce using rule 50 (EXPR -> identifier .)
    lt              reduce using rule 50 (EXPR -> identifier .)
    le              reduce using rule 50 (EXPR -> identifier .)
    equals          reduce using rule 50 (EXPR -> identifier .)
    comma           reduce using rule 50 (EXPR -> identifier .)
    semi            reduce using rule 50 (EXPR -> identifier .)
    in              reduce using rule 50 (EXPR -> identifier .)


state 154

    (22) EXPR -> let identifier colon type larrow EXPR LETHELPER in . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 159

state 155

    (18) CASEHELPER -> CASEHELPER identifier colon type rarrow . EXPR semi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 160

state 156

    (17) CASEHELPER -> identifier colon type rarrow EXPR . semi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    semi            shift and go to state 161
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 157

    (24) LETHELPER -> comma identifier colon type larrow . EXPR LETHELPER
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

    EXPR                           shift and go to state 162

state 158

    (23) LETHELPER -> comma identifier colon type LETHELPER .

    in              reduce using rule 23 (LETHELPER -> comma identifier colon type LETHELPER .)


state 159

    (22) EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
    pool            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    then            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rparen          reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    of              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    loop            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rbrace          reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    else            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    fi              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    in              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65
    semi            shift and go to state 62

  ! at              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 160

    (18) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR . semi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    semi            shift and go to state 163
    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 65

    EXPRLISTSEMI                   shift and go to state 66
    EXPRLISTCOMMA                  shift and go to state 63

state 161

    (17) CASEHELPER -> identifier colon type rarrow EXPR semi .
    (38) EXPRLISTSEMI -> semi . EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 17 (CASEHELPER -> identifier colon type rarrow EXPR semi .)
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

  ! identifier      [ reduce using rule 17 (CASEHELPER -> identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 89

state 162

    (24) LETHELPER -> comma identifier colon type larrow EXPR . LETHELPER
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . EXPRLISTCOMMA
    (35) EXPR -> EXPR . EXPRLISTSEMI
    (43) EXPR -> EXPR . plus EXPR
    (44) EXPR -> EXPR . minus EXPR
    (45) EXPR -> EXPR . times EXPR
    (46) EXPR -> EXPR . divide EXPR
    (47) EXPR -> EXPR . lt EXPR
    (48) EXPR -> EXPR . le EXPR
    (49) EXPR -> EXPR . equals EXPR
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .
    (36) EXPRLISTCOMMA -> . comma EXPR EXPRLISTCOMMA
    (37) EXPRLISTCOMMA -> . comma EXPR
    (38) EXPRLISTSEMI -> . semi EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> . semi EXPR

    at              shift and go to state 68
    dot             shift and go to state 71
    plus            shift and go to state 69
    minus           shift and go to state 70
    times           shift and go to state 72
    divide          shift and go to state 61
    lt              shift and go to state 67
    le              shift and go to state 60
    equals          shift and go to state 64
    comma           shift and go to state 146
    in              reduce using rule 25 (LETHELPER -> .)
    semi            shift and go to state 62

    EXPRLISTSEMI                   shift and go to state 66
    LETHELPER                      shift and go to state 164
    EXPRLISTCOMMA                  shift and go to state 63

state 163

    (18) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .
    (38) EXPRLISTSEMI -> semi . EXPR EXPRLISTSEMI
    (39) EXPRLISTSEMI -> semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR EXPRLISTCOMMA
    (35) EXPR -> . EXPR EXPRLISTSEMI
    (40) EXPR -> . isvoid EXPR
    (41) EXPR -> . tilde EXPR
    (42) EXPR -> . not EXPR
    (43) EXPR -> . EXPR plus EXPR
    (44) EXPR -> . EXPR minus EXPR
    (45) EXPR -> . EXPR times EXPR
    (46) EXPR -> . EXPR divide EXPR
    (47) EXPR -> . EXPR lt EXPR
    (48) EXPR -> . EXPR le EXPR
    (49) EXPR -> . EXPR equals EXPR
    (50) EXPR -> . identifier
    (51) EXPR -> . integer
    (52) EXPR -> . string
    (53) EXPR -> . true
    (54) EXPR -> . false
    (55) EXPR -> . identifier lparen rparen
    (56) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 18 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .)
    case            shift and go to state 50
    let             shift and go to state 45
    lparen          shift and go to state 46
    lbrace          shift and go to state 51
    identifier      shift and go to state 53
    if              shift and go to state 40
    while           shift and go to state 52
    isvoid          shift and go to state 43
    tilde           shift and go to state 39
    not             shift and go to state 48
    integer         shift and go to state 41
    string          shift and go to state 44
    true            shift and go to state 49
    false           shift and go to state 38
    new             shift and go to state 47

  ! identifier      [ reduce using rule 18 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 89

state 164

    (24) LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .

    in              reduce using rule 24 (LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for semi in state 24 resolved as shift
WARNING: shift/reduce conflict for semi in state 25 resolved as shift
WARNING: shift/reduce conflict for at in state 89 resolved as shift
WARNING: shift/reduce conflict for dot in state 89 resolved as shift
WARNING: shift/reduce conflict for plus in state 89 resolved as shift
WARNING: shift/reduce conflict for minus in state 89 resolved as shift
WARNING: shift/reduce conflict for times in state 89 resolved as shift
WARNING: shift/reduce conflict for divide in state 89 resolved as shift
WARNING: shift/reduce conflict for lt in state 89 resolved as shift
WARNING: shift/reduce conflict for le in state 89 resolved as shift
WARNING: shift/reduce conflict for equals in state 89 resolved as shift
WARNING: shift/reduce conflict for semi in state 89 resolved as shift
WARNING: shift/reduce conflict for comma in state 89 resolved as shift
WARNING: shift/reduce conflict for at in state 91 resolved as shift
WARNING: shift/reduce conflict for dot in state 91 resolved as shift
WARNING: shift/reduce conflict for plus in state 91 resolved as shift
WARNING: shift/reduce conflict for minus in state 91 resolved as shift
WARNING: shift/reduce conflict for times in state 91 resolved as shift
WARNING: shift/reduce conflict for divide in state 91 resolved as shift
WARNING: shift/reduce conflict for lt in state 91 resolved as shift
WARNING: shift/reduce conflict for le in state 91 resolved as shift
WARNING: shift/reduce conflict for equals in state 91 resolved as shift
WARNING: shift/reduce conflict for comma in state 91 resolved as shift
WARNING: shift/reduce conflict for semi in state 91 resolved as shift
WARNING: shift/reduce conflict for at in state 148 resolved as shift
WARNING: shift/reduce conflict for dot in state 148 resolved as shift
WARNING: shift/reduce conflict for plus in state 148 resolved as shift
WARNING: shift/reduce conflict for minus in state 148 resolved as shift
WARNING: shift/reduce conflict for times in state 148 resolved as shift
WARNING: shift/reduce conflict for divide in state 148 resolved as shift
WARNING: shift/reduce conflict for lt in state 148 resolved as shift
WARNING: shift/reduce conflict for le in state 148 resolved as shift
WARNING: shift/reduce conflict for equals in state 148 resolved as shift
WARNING: shift/reduce conflict for comma in state 148 resolved as shift
WARNING: shift/reduce conflict for semi in state 148 resolved as shift
WARNING: shift/reduce conflict for at in state 159 resolved as shift
WARNING: shift/reduce conflict for dot in state 159 resolved as shift
WARNING: shift/reduce conflict for plus in state 159 resolved as shift
WARNING: shift/reduce conflict for minus in state 159 resolved as shift
WARNING: shift/reduce conflict for times in state 159 resolved as shift
WARNING: shift/reduce conflict for divide in state 159 resolved as shift
WARNING: shift/reduce conflict for lt in state 159 resolved as shift
WARNING: shift/reduce conflict for le in state 159 resolved as shift
WARNING: shift/reduce conflict for equals in state 159 resolved as shift
WARNING: shift/reduce conflict for comma in state 159 resolved as shift
WARNING: shift/reduce conflict for semi in state 159 resolved as shift
WARNING: shift/reduce conflict for identifier in state 161 resolved as shift
WARNING: shift/reduce conflict for identifier in state 163 resolved as shift
WARNING: reduce/reduce conflict in state 110 resolved using rule (EXPR -> EXPR EXPRLISTSEMI)
WARNING: rejected rule (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (EXPR -> EXPR EXPRLISTCOMMA)
WARNING: rejected rule (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA) in state 111
WARNING: Rule (EXPRLISTSEMI -> semi EXPR EXPRLISTSEMI) is never reduced
WARNING: Rule (EXPRLISTCOMMA -> comma EXPR EXPRLISTCOMMA) is never reduced
