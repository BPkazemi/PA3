Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    inherits
    fi
    false
    rbrace
    in
    colon
    at
    tilde
    divide
    le
    rarrow
    isvoid
    larrow
    lt
    esac
    new
    if
    type
    then
    string
    equals
    else
    let
    lparen
    not
    true
    class
    pool
    case
    lbrace
    rparen
    semi
    of
    times
    while
    loop
    comma
    identifier
    minus
    dot

Grammar

Rule 0     S' -> expression
Rule 1     expression -> expression plus expression
Rule 2     expression -> integer

Terminals, with rules where they appear

at                   : 
case                 : 
class                : 
colon                : 
comma                : 
divide               : 
dot                  : 
else                 : 
equals               : 
error                : 
esac                 : 
false                : 
fi                   : 
identifier           : 
if                   : 
in                   : 
inherits             : 
integer              : 2
isvoid               : 
larrow               : 
lbrace               : 
le                   : 
let                  : 
loop                 : 
lparen               : 
lt                   : 
minus                : 
new                  : 
not                  : 
of                   : 
plus                 : 1
pool                 : 
rarrow               : 
rbrace               : 
rparen               : 
semi                 : 
string               : 
then                 : 
tilde                : 
times                : 
true                 : 
type                 : 
while                : 

Nonterminals, with rules where they appear

expression           : 1 1 0

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . expression plus expression
    (2) expression -> . integer

    integer         shift and go to state 2

    expression                     shift and go to state 1

state 1

    (0) S' -> expression .
    (1) expression -> expression . plus expression

    plus            shift and go to state 3


state 2

    (2) expression -> integer .

    plus            reduce using rule 2 (expression -> integer .)
    $end            reduce using rule 2 (expression -> integer .)


state 3

    (1) expression -> expression plus . expression
    (1) expression -> . expression plus expression
    (2) expression -> . integer

    integer         shift and go to state 2

    expression                     shift and go to state 4

state 4

    (1) expression -> expression plus expression .
    (1) expression -> expression . plus expression

  ! shift/reduce conflict for plus resolved as shift
    $end            reduce using rule 1 (expression -> expression plus expression .)
    plus            shift and go to state 3

  ! plus            [ reduce using rule 1 (expression -> expression plus expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for plus in state 4 resolved as shift
