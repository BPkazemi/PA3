Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> CLASSDEF semi
Rule 2     PROGRAM -> PROGRAM CLASSDEF semi
Rule 3     CLASSDEF -> class type lbrace rbrace
Rule 4     CLASSDEF -> class type lbrace FEATURE semi rbrace
Rule 5     CLASSDEF -> class type inherits type lbrace rbrace
Rule 6     CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace
Rule 7     FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
Rule 8     FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace
Rule 9     FEATURE -> identifier colon type
Rule 10    FEATURE -> identifier colon type larrow EXPR
Rule 11    FEATURE -> FEATURE semi FEATURE
Rule 12    FORMAL -> identifier colon type
Rule 13    FORMAL -> FORMAL comma identifier colon type
Rule 14    EXPR -> case EXPR of CASEHELPER esac
Rule 15    CASEHELPER -> identifier colon type rarrow EXPR semi
Rule 16    CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi
Rule 17    EXPR -> EXPR at type dot identifier lparen EXPR rparen
Rule 18    EXPR -> EXPR dot identifier lparen EXPR rparen
Rule 19    EXPR -> let identifier colon type LETHELPER in EXPR
Rule 20    EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR
Rule 21    LETHELPER -> comma identifier colon type LETHELPER
Rule 22    LETHELPER -> comma identifier colon type larrow EXPR LETHELPER
Rule 23    LETHELPER -> <empty>
Rule 24    EXPR -> lparen EXPR rparen
Rule 25    EXPR -> lbrace EXPR semi rbrace
Rule 26    EXPR -> identifier larrow EXPR
Rule 27    EXPR -> identifier lparen EXPR rparen
Rule 28    EXPR -> EXPR at type dot identifier lparen rparen
Rule 29    EXPR -> EXPR dot identifier lparen rparen
Rule 30    EXPR -> if EXPR then EXPR else EXPR fi
Rule 31    EXPR -> while EXPR loop EXPR pool
Rule 32    EXPR -> EXPR comma EXPR
Rule 33    EXPR -> EXPR semi EXPR
Rule 34    EXPR -> isvoid EXPR
Rule 35    EXPR -> tilde EXPR
Rule 36    EXPR -> not EXPR
Rule 37    EXPR -> EXPR plus EXPR
Rule 38    EXPR -> EXPR minus EXPR
Rule 39    EXPR -> EXPR times EXPR
Rule 40    EXPR -> EXPR divide EXPR
Rule 41    EXPR -> EXPR lt EXPR
Rule 42    EXPR -> EXPR le EXPR
Rule 43    EXPR -> EXPR equals EXPR
Rule 44    EXPR -> identifier
Rule 45    EXPR -> integer
Rule 46    EXPR -> string
Rule 47    EXPR -> true
Rule 48    EXPR -> false
Rule 49    EXPR -> identifier lparen rparen
Rule 50    EXPR -> new type

Terminals, with rules where they appear

at                   : 17 28
case                 : 14
class                : 3 4 5 6
colon                : 7 8 9 10 12 13 15 16 19 20 21 22
comma                : 13 21 22 32
divide               : 40
dot                  : 17 18 28 29
else                 : 30
equals               : 43
error                : 
esac                 : 14
false                : 48
fi                   : 30
identifier           : 7 8 9 10 12 13 15 16 17 18 19 20 21 22 26 27 28 29 44 49
if                   : 30
in                   : 19 20
inherits             : 5 6
integer              : 45
isvoid               : 34
larrow               : 10 20 22 26
lbrace               : 3 4 5 6 7 8 25
le                   : 42
let                  : 19 20
loop                 : 31
lparen               : 7 8 17 18 24 27 28 29 49
lt                   : 41
minus                : 38
new                  : 50
not                  : 36
of                   : 14
plus                 : 37
pool                 : 31
rarrow               : 15 16
rbrace               : 3 4 5 6 7 8 25
rparen               : 7 8 17 18 24 27 28 29 49
semi                 : 1 2 4 6 11 15 16 25 33
string               : 46
then                 : 30
tilde                : 35
times                : 39
true                 : 47
type                 : 3 4 5 5 6 6 7 8 9 10 12 13 15 16 17 19 20 21 22 28 50
while                : 31

Nonterminals, with rules where they appear

CASEHELPER           : 14 16
CLASSDEF             : 1 2
EXPR                 : 7 8 10 14 15 16 17 17 18 18 19 20 20 22 24 25 26 27 28 29 30 30 30 31 31 32 32 33 33 34 35 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43
FEATURE              : 4 6 11 11
FORMAL               : 7 13
LETHELPER            : 19 20 21 22
PROGRAM              : 2 0

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . CLASSDEF semi
    (2) PROGRAM -> . PROGRAM CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 3

    PROGRAM                        shift and go to state 2
    CLASSDEF                       shift and go to state 1

state 1

    (1) PROGRAM -> CLASSDEF . semi

    semi            shift and go to state 4


state 2

    (0) S' -> PROGRAM .
    (2) PROGRAM -> PROGRAM . CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 3

    CLASSDEF                       shift and go to state 5

state 3

    (3) CLASSDEF -> class . type lbrace rbrace
    (4) CLASSDEF -> class . type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class . type inherits type lbrace rbrace
    (6) CLASSDEF -> class . type inherits type lbrace FEATURE semi rbrace

    type            shift and go to state 6


state 4

    (1) PROGRAM -> CLASSDEF semi .

    class           reduce using rule 1 (PROGRAM -> CLASSDEF semi .)
    $end            reduce using rule 1 (PROGRAM -> CLASSDEF semi .)


state 5

    (2) PROGRAM -> PROGRAM CLASSDEF . semi

    semi            shift and go to state 7


state 6

    (3) CLASSDEF -> class type . lbrace rbrace
    (4) CLASSDEF -> class type . lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class type . inherits type lbrace rbrace
    (6) CLASSDEF -> class type . inherits type lbrace FEATURE semi rbrace

    lbrace          shift and go to state 9
    inherits        shift and go to state 8


state 7

    (2) PROGRAM -> PROGRAM CLASSDEF semi .

    class           reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)
    $end            reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)


state 8

    (5) CLASSDEF -> class type inherits . type lbrace rbrace
    (6) CLASSDEF -> class type inherits . type lbrace FEATURE semi rbrace

    type            shift and go to state 10


state 9

    (3) CLASSDEF -> class type lbrace . rbrace
    (4) CLASSDEF -> class type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 11
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 12

state 10

    (5) CLASSDEF -> class type inherits type . lbrace rbrace
    (6) CLASSDEF -> class type inherits type . lbrace FEATURE semi rbrace

    lbrace          shift and go to state 14


state 11

    (3) CLASSDEF -> class type lbrace rbrace .

    semi            reduce using rule 3 (CLASSDEF -> class type lbrace rbrace .)


state 12

    (4) CLASSDEF -> class type lbrace FEATURE . semi rbrace
    (11) FEATURE -> FEATURE . semi FEATURE

    semi            shift and go to state 15


state 13

    (7) FEATURE -> identifier . lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier . lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> identifier . colon type
    (10) FEATURE -> identifier . colon type larrow EXPR

    lparen          shift and go to state 17
    colon           shift and go to state 16


state 14

    (5) CLASSDEF -> class type inherits type lbrace . rbrace
    (6) CLASSDEF -> class type inherits type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 18
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 19

state 15

    (4) CLASSDEF -> class type lbrace FEATURE semi . rbrace
    (11) FEATURE -> FEATURE semi . FEATURE
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 20
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 21

state 16

    (9) FEATURE -> identifier colon . type
    (10) FEATURE -> identifier colon . type larrow EXPR

    type            shift and go to state 22


state 17

    (7) FEATURE -> identifier lparen . FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier lparen . rparen colon type lbrace EXPR rbrace
    (12) FORMAL -> . identifier colon type
    (13) FORMAL -> . FORMAL comma identifier colon type

    rparen          shift and go to state 23
    identifier      shift and go to state 24

    FORMAL                         shift and go to state 25

state 18

    (5) CLASSDEF -> class type inherits type lbrace rbrace .

    semi            reduce using rule 5 (CLASSDEF -> class type inherits type lbrace rbrace .)


state 19

    (6) CLASSDEF -> class type inherits type lbrace FEATURE . semi rbrace
    (11) FEATURE -> FEATURE . semi FEATURE

    semi            shift and go to state 26


state 20

    (4) CLASSDEF -> class type lbrace FEATURE semi rbrace .

    semi            reduce using rule 4 (CLASSDEF -> class type lbrace FEATURE semi rbrace .)


state 21

    (11) FEATURE -> FEATURE semi FEATURE .
    (11) FEATURE -> FEATURE . semi FEATURE

  ! shift/reduce conflict for semi resolved as shift
    semi            shift and go to state 27

  ! semi            [ reduce using rule 11 (FEATURE -> FEATURE semi FEATURE .) ]


state 22

    (9) FEATURE -> identifier colon type .
    (10) FEATURE -> identifier colon type . larrow EXPR

    semi            reduce using rule 9 (FEATURE -> identifier colon type .)
    larrow          shift and go to state 28


state 23

    (8) FEATURE -> identifier lparen rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 29


state 24

    (12) FORMAL -> identifier . colon type

    colon           shift and go to state 30


state 25

    (7) FEATURE -> identifier lparen FORMAL . rparen colon type lbrace EXPR rbrace
    (13) FORMAL -> FORMAL . comma identifier colon type

    rparen          shift and go to state 31
    comma           shift and go to state 32


state 26

    (6) CLASSDEF -> class type inherits type lbrace FEATURE semi . rbrace
    (11) FEATURE -> FEATURE semi . FEATURE
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURE semi FEATURE

    rbrace          shift and go to state 33
    identifier      shift and go to state 13

    FEATURE                        shift and go to state 21

state 27

    (11) FEATURE -> FEATURE semi . FEATURE
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURE semi FEATURE

    identifier      shift and go to state 13

    FEATURE                        shift and go to state 21

state 28

    (10) FEATURE -> identifier colon type larrow . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 38

state 29

    (8) FEATURE -> identifier lparen rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 50


state 30

    (12) FORMAL -> identifier colon . type

    type            shift and go to state 51


state 31

    (7) FEATURE -> identifier lparen FORMAL rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 52


state 32

    (13) FORMAL -> FORMAL comma . identifier colon type

    identifier      shift and go to state 53


state 33

    (6) CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .

    semi            reduce using rule 6 (CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .)


state 34

    (48) EXPR -> false .

    rbrace          reduce using rule 48 (EXPR -> false .)
    at              reduce using rule 48 (EXPR -> false .)
    dot             reduce using rule 48 (EXPR -> false .)
    comma           reduce using rule 48 (EXPR -> false .)
    semi            reduce using rule 48 (EXPR -> false .)
    plus            reduce using rule 48 (EXPR -> false .)
    minus           reduce using rule 48 (EXPR -> false .)
    times           reduce using rule 48 (EXPR -> false .)
    divide          reduce using rule 48 (EXPR -> false .)
    lt              reduce using rule 48 (EXPR -> false .)
    le              reduce using rule 48 (EXPR -> false .)
    equals          reduce using rule 48 (EXPR -> false .)
    rparen          reduce using rule 48 (EXPR -> false .)
    then            reduce using rule 48 (EXPR -> false .)
    of              reduce using rule 48 (EXPR -> false .)
    loop            reduce using rule 48 (EXPR -> false .)
    else            reduce using rule 48 (EXPR -> false .)
    pool            reduce using rule 48 (EXPR -> false .)
    fi              reduce using rule 48 (EXPR -> false .)
    in              reduce using rule 48 (EXPR -> false .)


state 35

    (35) EXPR -> tilde . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 54

state 36

    (30) EXPR -> if . EXPR then EXPR else EXPR fi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 55

state 37

    (45) EXPR -> integer .

    rbrace          reduce using rule 45 (EXPR -> integer .)
    at              reduce using rule 45 (EXPR -> integer .)
    dot             reduce using rule 45 (EXPR -> integer .)
    comma           reduce using rule 45 (EXPR -> integer .)
    semi            reduce using rule 45 (EXPR -> integer .)
    plus            reduce using rule 45 (EXPR -> integer .)
    minus           reduce using rule 45 (EXPR -> integer .)
    times           reduce using rule 45 (EXPR -> integer .)
    divide          reduce using rule 45 (EXPR -> integer .)
    lt              reduce using rule 45 (EXPR -> integer .)
    le              reduce using rule 45 (EXPR -> integer .)
    equals          reduce using rule 45 (EXPR -> integer .)
    rparen          reduce using rule 45 (EXPR -> integer .)
    then            reduce using rule 45 (EXPR -> integer .)
    of              reduce using rule 45 (EXPR -> integer .)
    loop            reduce using rule 45 (EXPR -> integer .)
    else            reduce using rule 45 (EXPR -> integer .)
    pool            reduce using rule 45 (EXPR -> integer .)
    fi              reduce using rule 45 (EXPR -> integer .)
    in              reduce using rule 45 (EXPR -> integer .)


state 38

    (10) FEATURE -> identifier colon type larrow EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 10 (FEATURE -> identifier colon type larrow EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! semi            [ shift and go to state 58 ]


state 39

    (34) EXPR -> isvoid . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 67

state 40

    (46) EXPR -> string .

    rbrace          reduce using rule 46 (EXPR -> string .)
    at              reduce using rule 46 (EXPR -> string .)
    dot             reduce using rule 46 (EXPR -> string .)
    comma           reduce using rule 46 (EXPR -> string .)
    semi            reduce using rule 46 (EXPR -> string .)
    plus            reduce using rule 46 (EXPR -> string .)
    minus           reduce using rule 46 (EXPR -> string .)
    times           reduce using rule 46 (EXPR -> string .)
    divide          reduce using rule 46 (EXPR -> string .)
    lt              reduce using rule 46 (EXPR -> string .)
    le              reduce using rule 46 (EXPR -> string .)
    equals          reduce using rule 46 (EXPR -> string .)
    rparen          reduce using rule 46 (EXPR -> string .)
    then            reduce using rule 46 (EXPR -> string .)
    of              reduce using rule 46 (EXPR -> string .)
    loop            reduce using rule 46 (EXPR -> string .)
    else            reduce using rule 46 (EXPR -> string .)
    pool            reduce using rule 46 (EXPR -> string .)
    fi              reduce using rule 46 (EXPR -> string .)
    in              reduce using rule 46 (EXPR -> string .)


state 41

    (19) EXPR -> let . identifier colon type LETHELPER in EXPR
    (20) EXPR -> let . identifier colon type larrow EXPR LETHELPER in EXPR

    identifier      shift and go to state 68


state 42

    (24) EXPR -> lparen . EXPR rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 69

state 43

    (50) EXPR -> new . type

    type            shift and go to state 70


state 44

    (36) EXPR -> not . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 71

state 45

    (47) EXPR -> true .

    rbrace          reduce using rule 47 (EXPR -> true .)
    at              reduce using rule 47 (EXPR -> true .)
    dot             reduce using rule 47 (EXPR -> true .)
    comma           reduce using rule 47 (EXPR -> true .)
    semi            reduce using rule 47 (EXPR -> true .)
    plus            reduce using rule 47 (EXPR -> true .)
    minus           reduce using rule 47 (EXPR -> true .)
    times           reduce using rule 47 (EXPR -> true .)
    divide          reduce using rule 47 (EXPR -> true .)
    lt              reduce using rule 47 (EXPR -> true .)
    le              reduce using rule 47 (EXPR -> true .)
    equals          reduce using rule 47 (EXPR -> true .)
    rparen          reduce using rule 47 (EXPR -> true .)
    then            reduce using rule 47 (EXPR -> true .)
    of              reduce using rule 47 (EXPR -> true .)
    loop            reduce using rule 47 (EXPR -> true .)
    else            reduce using rule 47 (EXPR -> true .)
    pool            reduce using rule 47 (EXPR -> true .)
    fi              reduce using rule 47 (EXPR -> true .)
    in              reduce using rule 47 (EXPR -> true .)


state 46

    (14) EXPR -> case . EXPR of CASEHELPER esac
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 72

state 47

    (25) EXPR -> lbrace . EXPR semi rbrace
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 73

state 48

    (31) EXPR -> while . EXPR loop EXPR pool
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 74

state 49

    (26) EXPR -> identifier . larrow EXPR
    (27) EXPR -> identifier . lparen EXPR rparen
    (44) EXPR -> identifier .
    (49) EXPR -> identifier . lparen rparen

    larrow          shift and go to state 75
    lparen          shift and go to state 76
    rbrace          reduce using rule 44 (EXPR -> identifier .)
    at              reduce using rule 44 (EXPR -> identifier .)
    dot             reduce using rule 44 (EXPR -> identifier .)
    comma           reduce using rule 44 (EXPR -> identifier .)
    semi            reduce using rule 44 (EXPR -> identifier .)
    plus            reduce using rule 44 (EXPR -> identifier .)
    minus           reduce using rule 44 (EXPR -> identifier .)
    times           reduce using rule 44 (EXPR -> identifier .)
    divide          reduce using rule 44 (EXPR -> identifier .)
    lt              reduce using rule 44 (EXPR -> identifier .)
    le              reduce using rule 44 (EXPR -> identifier .)
    equals          reduce using rule 44 (EXPR -> identifier .)
    rparen          reduce using rule 44 (EXPR -> identifier .)
    then            reduce using rule 44 (EXPR -> identifier .)
    of              reduce using rule 44 (EXPR -> identifier .)
    loop            reduce using rule 44 (EXPR -> identifier .)
    else            reduce using rule 44 (EXPR -> identifier .)
    pool            reduce using rule 44 (EXPR -> identifier .)
    fi              reduce using rule 44 (EXPR -> identifier .)
    in              reduce using rule 44 (EXPR -> identifier .)


state 50

    (8) FEATURE -> identifier lparen rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 77


state 51

    (12) FORMAL -> identifier colon type .

    rparen          reduce using rule 12 (FORMAL -> identifier colon type .)
    comma           reduce using rule 12 (FORMAL -> identifier colon type .)


state 52

    (7) FEATURE -> identifier lparen FORMAL rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 78


state 53

    (13) FORMAL -> FORMAL comma identifier . colon type

    colon           shift and go to state 79


state 54

    (35) EXPR -> tilde EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 35 (EXPR -> tilde EXPR .)
    comma           reduce using rule 35 (EXPR -> tilde EXPR .)
    semi            reduce using rule 35 (EXPR -> tilde EXPR .)
    plus            reduce using rule 35 (EXPR -> tilde EXPR .)
    minus           reduce using rule 35 (EXPR -> tilde EXPR .)
    times           reduce using rule 35 (EXPR -> tilde EXPR .)
    divide          reduce using rule 35 (EXPR -> tilde EXPR .)
    lt              reduce using rule 35 (EXPR -> tilde EXPR .)
    le              reduce using rule 35 (EXPR -> tilde EXPR .)
    equals          reduce using rule 35 (EXPR -> tilde EXPR .)
    rparen          reduce using rule 35 (EXPR -> tilde EXPR .)
    then            reduce using rule 35 (EXPR -> tilde EXPR .)
    of              reduce using rule 35 (EXPR -> tilde EXPR .)
    loop            reduce using rule 35 (EXPR -> tilde EXPR .)
    else            reduce using rule 35 (EXPR -> tilde EXPR .)
    pool            reduce using rule 35 (EXPR -> tilde EXPR .)
    fi              reduce using rule 35 (EXPR -> tilde EXPR .)
    in              reduce using rule 35 (EXPR -> tilde EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 35 (EXPR -> tilde EXPR .) ]
  ! dot             [ reduce using rule 35 (EXPR -> tilde EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! plus            [ shift and go to state 56 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 60 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 55

    (30) EXPR -> if EXPR . then EXPR else EXPR fi
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    then            shift and go to state 80
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 56

    (37) EXPR -> EXPR plus . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 81

state 57

    (40) EXPR -> EXPR divide . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 82

state 58

    (33) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 83

state 59

    (43) EXPR -> EXPR equals . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 84

state 60

    (39) EXPR -> EXPR times . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 85

state 61

    (41) EXPR -> EXPR lt . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 86

state 62

    (42) EXPR -> EXPR le . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 87

state 63

    (17) EXPR -> EXPR at . type dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR at . type dot identifier lparen rparen

    type            shift and go to state 88


state 64

    (32) EXPR -> EXPR comma . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 89

state 65

    (38) EXPR -> EXPR minus . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 90

state 66

    (18) EXPR -> EXPR dot . identifier lparen EXPR rparen
    (29) EXPR -> EXPR dot . identifier lparen rparen

    identifier      shift and go to state 91


state 67

    (34) EXPR -> isvoid EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 34 (EXPR -> isvoid EXPR .)
    comma           reduce using rule 34 (EXPR -> isvoid EXPR .)
    semi            reduce using rule 34 (EXPR -> isvoid EXPR .)
    plus            reduce using rule 34 (EXPR -> isvoid EXPR .)
    minus           reduce using rule 34 (EXPR -> isvoid EXPR .)
    times           reduce using rule 34 (EXPR -> isvoid EXPR .)
    divide          reduce using rule 34 (EXPR -> isvoid EXPR .)
    lt              reduce using rule 34 (EXPR -> isvoid EXPR .)
    le              reduce using rule 34 (EXPR -> isvoid EXPR .)
    equals          reduce using rule 34 (EXPR -> isvoid EXPR .)
    rparen          reduce using rule 34 (EXPR -> isvoid EXPR .)
    then            reduce using rule 34 (EXPR -> isvoid EXPR .)
    of              reduce using rule 34 (EXPR -> isvoid EXPR .)
    loop            reduce using rule 34 (EXPR -> isvoid EXPR .)
    else            reduce using rule 34 (EXPR -> isvoid EXPR .)
    pool            reduce using rule 34 (EXPR -> isvoid EXPR .)
    fi              reduce using rule 34 (EXPR -> isvoid EXPR .)
    in              reduce using rule 34 (EXPR -> isvoid EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 34 (EXPR -> isvoid EXPR .) ]
  ! dot             [ reduce using rule 34 (EXPR -> isvoid EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! plus            [ shift and go to state 56 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 60 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 68

    (19) EXPR -> let identifier . colon type LETHELPER in EXPR
    (20) EXPR -> let identifier . colon type larrow EXPR LETHELPER in EXPR

    colon           shift and go to state 92


state 69

    (24) EXPR -> lparen EXPR . rparen
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 93
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 70

    (50) EXPR -> new type .

    rbrace          reduce using rule 50 (EXPR -> new type .)
    at              reduce using rule 50 (EXPR -> new type .)
    dot             reduce using rule 50 (EXPR -> new type .)
    comma           reduce using rule 50 (EXPR -> new type .)
    semi            reduce using rule 50 (EXPR -> new type .)
    plus            reduce using rule 50 (EXPR -> new type .)
    minus           reduce using rule 50 (EXPR -> new type .)
    times           reduce using rule 50 (EXPR -> new type .)
    divide          reduce using rule 50 (EXPR -> new type .)
    lt              reduce using rule 50 (EXPR -> new type .)
    le              reduce using rule 50 (EXPR -> new type .)
    equals          reduce using rule 50 (EXPR -> new type .)
    rparen          reduce using rule 50 (EXPR -> new type .)
    then            reduce using rule 50 (EXPR -> new type .)
    of              reduce using rule 50 (EXPR -> new type .)
    loop            reduce using rule 50 (EXPR -> new type .)
    else            reduce using rule 50 (EXPR -> new type .)
    pool            reduce using rule 50 (EXPR -> new type .)
    fi              reduce using rule 50 (EXPR -> new type .)
    in              reduce using rule 50 (EXPR -> new type .)


state 71

    (36) EXPR -> not EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 36 (EXPR -> not EXPR .)
    comma           reduce using rule 36 (EXPR -> not EXPR .)
    semi            reduce using rule 36 (EXPR -> not EXPR .)
    rparen          reduce using rule 36 (EXPR -> not EXPR .)
    then            reduce using rule 36 (EXPR -> not EXPR .)
    of              reduce using rule 36 (EXPR -> not EXPR .)
    loop            reduce using rule 36 (EXPR -> not EXPR .)
    else            reduce using rule 36 (EXPR -> not EXPR .)
    pool            reduce using rule 36 (EXPR -> not EXPR .)
    fi              reduce using rule 36 (EXPR -> not EXPR .)
    in              reduce using rule 36 (EXPR -> not EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! at              [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! dot             [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! plus            [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! minus           [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! times           [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! divide          [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! lt              [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! le              [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! equals          [ reduce using rule 36 (EXPR -> not EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]


state 72

    (14) EXPR -> case EXPR . of CASEHELPER esac
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    of              shift and go to state 94
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 73

    (25) EXPR -> lbrace EXPR . semi rbrace
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 95
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 74

    (31) EXPR -> while EXPR . loop EXPR pool
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    loop            shift and go to state 96
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 75

    (26) EXPR -> identifier larrow . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 97

state 76

    (27) EXPR -> identifier lparen . EXPR rparen
    (49) EXPR -> identifier lparen . rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    rparen          shift and go to state 99
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 98

state 77

    (8) FEATURE -> identifier lparen rparen colon type lbrace . EXPR rbrace
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 100

state 78

    (7) FEATURE -> identifier lparen FORMAL rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 101


state 79

    (13) FORMAL -> FORMAL comma identifier colon . type

    type            shift and go to state 102


state 80

    (30) EXPR -> if EXPR then . EXPR else EXPR fi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 103

state 81

    (37) EXPR -> EXPR plus EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    comma           reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    semi            reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    plus            reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    lt              reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    le              reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    rparen          reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    then            reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    of              reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    loop            reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    pool            reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    fi              reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    in              reduce using rule 37 (EXPR -> EXPR plus EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    times           shift and go to state 60
    divide          shift and go to state 57

  ! at              [ reduce using rule 37 (EXPR -> EXPR plus EXPR .) ]
  ! dot             [ reduce using rule 37 (EXPR -> EXPR plus EXPR .) ]
  ! times           [ reduce using rule 37 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 37 (EXPR -> EXPR plus EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! plus            [ shift and go to state 56 ]
  ! minus           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 82

    (40) EXPR -> EXPR divide EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    comma           reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    semi            reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    plus            reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    lt              reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    le              reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    rparen          reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    then            reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    of              reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    loop            reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    pool            reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    fi              reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    in              reduce using rule 40 (EXPR -> EXPR divide EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 40 (EXPR -> EXPR divide EXPR .) ]
  ! dot             [ reduce using rule 40 (EXPR -> EXPR divide EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! plus            [ shift and go to state 56 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 60 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 83

    (33) EXPR -> EXPR semi EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    rparen          reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    then            reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    of              reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    loop            reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    else            reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    pool            reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    fi              reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    in              reduce using rule 33 (EXPR -> EXPR semi EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! at              [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! dot             [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! comma           [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! semi            [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! plus            [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! minus           [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! times           [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! divide          [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! lt              [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! le              [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]
  ! equals          [ reduce using rule 33 (EXPR -> EXPR semi EXPR .) ]


state 84

    (43) EXPR -> EXPR equals EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    comma           reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    semi            reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    lt              reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    le              reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    equals          reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    rparen          reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    then            reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    of              reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    loop            reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    else            reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    pool            reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    fi              reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    in              reduce using rule 43 (EXPR -> EXPR equals EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57

  ! at              [ reduce using rule 43 (EXPR -> EXPR equals EXPR .) ]
  ! dot             [ reduce using rule 43 (EXPR -> EXPR equals EXPR .) ]
  ! plus            [ reduce using rule 43 (EXPR -> EXPR equals EXPR .) ]
  ! minus           [ reduce using rule 43 (EXPR -> EXPR equals EXPR .) ]
  ! times           [ reduce using rule 43 (EXPR -> EXPR equals EXPR .) ]
  ! divide          [ reduce using rule 43 (EXPR -> EXPR equals EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 85

    (39) EXPR -> EXPR times EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 39 (EXPR -> EXPR times EXPR .)
    comma           reduce using rule 39 (EXPR -> EXPR times EXPR .)
    semi            reduce using rule 39 (EXPR -> EXPR times EXPR .)
    plus            reduce using rule 39 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 39 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 39 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 39 (EXPR -> EXPR times EXPR .)
    lt              reduce using rule 39 (EXPR -> EXPR times EXPR .)
    le              reduce using rule 39 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 39 (EXPR -> EXPR times EXPR .)
    rparen          reduce using rule 39 (EXPR -> EXPR times EXPR .)
    then            reduce using rule 39 (EXPR -> EXPR times EXPR .)
    of              reduce using rule 39 (EXPR -> EXPR times EXPR .)
    loop            reduce using rule 39 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 39 (EXPR -> EXPR times EXPR .)
    pool            reduce using rule 39 (EXPR -> EXPR times EXPR .)
    fi              reduce using rule 39 (EXPR -> EXPR times EXPR .)
    in              reduce using rule 39 (EXPR -> EXPR times EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 39 (EXPR -> EXPR times EXPR .) ]
  ! dot             [ reduce using rule 39 (EXPR -> EXPR times EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! plus            [ shift and go to state 56 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 60 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 86

    (41) EXPR -> EXPR lt EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    comma           reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    semi            reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    lt              reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    le              reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    equals          reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    rparen          reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    then            reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    of              reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    loop            reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    else            reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    pool            reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    fi              reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    in              reduce using rule 41 (EXPR -> EXPR lt EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57

  ! at              [ reduce using rule 41 (EXPR -> EXPR lt EXPR .) ]
  ! dot             [ reduce using rule 41 (EXPR -> EXPR lt EXPR .) ]
  ! plus            [ reduce using rule 41 (EXPR -> EXPR lt EXPR .) ]
  ! minus           [ reduce using rule 41 (EXPR -> EXPR lt EXPR .) ]
  ! times           [ reduce using rule 41 (EXPR -> EXPR lt EXPR .) ]
  ! divide          [ reduce using rule 41 (EXPR -> EXPR lt EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 87

    (42) EXPR -> EXPR le EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 42 (EXPR -> EXPR le EXPR .)
    comma           reduce using rule 42 (EXPR -> EXPR le EXPR .)
    semi            reduce using rule 42 (EXPR -> EXPR le EXPR .)
    lt              reduce using rule 42 (EXPR -> EXPR le EXPR .)
    le              reduce using rule 42 (EXPR -> EXPR le EXPR .)
    equals          reduce using rule 42 (EXPR -> EXPR le EXPR .)
    rparen          reduce using rule 42 (EXPR -> EXPR le EXPR .)
    then            reduce using rule 42 (EXPR -> EXPR le EXPR .)
    of              reduce using rule 42 (EXPR -> EXPR le EXPR .)
    loop            reduce using rule 42 (EXPR -> EXPR le EXPR .)
    else            reduce using rule 42 (EXPR -> EXPR le EXPR .)
    pool            reduce using rule 42 (EXPR -> EXPR le EXPR .)
    fi              reduce using rule 42 (EXPR -> EXPR le EXPR .)
    in              reduce using rule 42 (EXPR -> EXPR le EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57

  ! at              [ reduce using rule 42 (EXPR -> EXPR le EXPR .) ]
  ! dot             [ reduce using rule 42 (EXPR -> EXPR le EXPR .) ]
  ! plus            [ reduce using rule 42 (EXPR -> EXPR le EXPR .) ]
  ! minus           [ reduce using rule 42 (EXPR -> EXPR le EXPR .) ]
  ! times           [ reduce using rule 42 (EXPR -> EXPR le EXPR .) ]
  ! divide          [ reduce using rule 42 (EXPR -> EXPR le EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 88

    (17) EXPR -> EXPR at type . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR at type . dot identifier lparen rparen

    dot             shift and go to state 104


state 89

    (32) EXPR -> EXPR comma EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    rparen          reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    then            reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    of              reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    loop            reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    else            reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    pool            reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    fi              reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    in              reduce using rule 32 (EXPR -> EXPR comma EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! at              [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! dot             [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! comma           [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! semi            [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! plus            [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! minus           [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! times           [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! divide          [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! lt              [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! le              [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]
  ! equals          [ reduce using rule 32 (EXPR -> EXPR comma EXPR .) ]


state 90

    (38) EXPR -> EXPR minus EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    comma           reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    semi            reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    plus            reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    lt              reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    le              reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    rparen          reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    then            reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    of              reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    loop            reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    pool            reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    fi              reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    in              reduce using rule 38 (EXPR -> EXPR minus EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    times           shift and go to state 60
    divide          shift and go to state 57

  ! at              [ reduce using rule 38 (EXPR -> EXPR minus EXPR .) ]
  ! dot             [ reduce using rule 38 (EXPR -> EXPR minus EXPR .) ]
  ! times           [ reduce using rule 38 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 38 (EXPR -> EXPR minus EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]
  ! plus            [ shift and go to state 56 ]
  ! minus           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 61 ]
  ! le              [ shift and go to state 62 ]
  ! equals          [ shift and go to state 59 ]


state 91

    (18) EXPR -> EXPR dot identifier . lparen EXPR rparen
    (29) EXPR -> EXPR dot identifier . lparen rparen

    lparen          shift and go to state 105


state 92

    (19) EXPR -> let identifier colon . type LETHELPER in EXPR
    (20) EXPR -> let identifier colon . type larrow EXPR LETHELPER in EXPR

    type            shift and go to state 106


state 93

    (24) EXPR -> lparen EXPR rparen .

    rbrace          reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    at              reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    dot             reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    comma           reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    semi            reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    plus            reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    minus           reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    times           reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    divide          reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    lt              reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    le              reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    equals          reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    rparen          reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    then            reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    of              reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    loop            reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    else            reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    pool            reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    fi              reduce using rule 24 (EXPR -> lparen EXPR rparen .)
    in              reduce using rule 24 (EXPR -> lparen EXPR rparen .)


state 94

    (14) EXPR -> case EXPR of . CASEHELPER esac
    (15) CASEHELPER -> . identifier colon type rarrow EXPR semi
    (16) CASEHELPER -> . CASEHELPER identifier colon type rarrow EXPR semi

    identifier      shift and go to state 108

    CASEHELPER                     shift and go to state 107

state 95

    (25) EXPR -> lbrace EXPR semi . rbrace
    (33) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    rbrace          shift and go to state 109
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 83

state 96

    (31) EXPR -> while EXPR loop . EXPR pool
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 110

state 97

    (26) EXPR -> identifier larrow EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    comma           reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    semi            reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    rparen          reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    then            reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    of              reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    loop            reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    else            reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    pool            reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    fi              reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    in              reduce using rule 26 (EXPR -> identifier larrow EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! at              [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! dot             [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! plus            [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! minus           [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! times           [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! divide          [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! lt              [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! le              [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! equals          [ reduce using rule 26 (EXPR -> identifier larrow EXPR .) ]
  ! comma           [ shift and go to state 64 ]
  ! semi            [ shift and go to state 58 ]


state 98

    (27) EXPR -> identifier lparen EXPR . rparen
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 111
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 99

    (49) EXPR -> identifier lparen rparen .

    rbrace          reduce using rule 49 (EXPR -> identifier lparen rparen .)
    at              reduce using rule 49 (EXPR -> identifier lparen rparen .)
    dot             reduce using rule 49 (EXPR -> identifier lparen rparen .)
    comma           reduce using rule 49 (EXPR -> identifier lparen rparen .)
    semi            reduce using rule 49 (EXPR -> identifier lparen rparen .)
    plus            reduce using rule 49 (EXPR -> identifier lparen rparen .)
    minus           reduce using rule 49 (EXPR -> identifier lparen rparen .)
    times           reduce using rule 49 (EXPR -> identifier lparen rparen .)
    divide          reduce using rule 49 (EXPR -> identifier lparen rparen .)
    lt              reduce using rule 49 (EXPR -> identifier lparen rparen .)
    le              reduce using rule 49 (EXPR -> identifier lparen rparen .)
    equals          reduce using rule 49 (EXPR -> identifier lparen rparen .)
    rparen          reduce using rule 49 (EXPR -> identifier lparen rparen .)
    then            reduce using rule 49 (EXPR -> identifier lparen rparen .)
    of              reduce using rule 49 (EXPR -> identifier lparen rparen .)
    loop            reduce using rule 49 (EXPR -> identifier lparen rparen .)
    else            reduce using rule 49 (EXPR -> identifier lparen rparen .)
    pool            reduce using rule 49 (EXPR -> identifier lparen rparen .)
    fi              reduce using rule 49 (EXPR -> identifier lparen rparen .)
    in              reduce using rule 49 (EXPR -> identifier lparen rparen .)


state 100

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR . rbrace
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 112
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 101

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace . EXPR rbrace
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 113

state 102

    (13) FORMAL -> FORMAL comma identifier colon type .

    rparen          reduce using rule 13 (FORMAL -> FORMAL comma identifier colon type .)
    comma           reduce using rule 13 (FORMAL -> FORMAL comma identifier colon type .)


state 103

    (30) EXPR -> if EXPR then EXPR . else EXPR fi
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    else            shift and go to state 114
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 104

    (17) EXPR -> EXPR at type dot . identifier lparen EXPR rparen
    (28) EXPR -> EXPR at type dot . identifier lparen rparen

    identifier      shift and go to state 115


state 105

    (18) EXPR -> EXPR dot identifier lparen . EXPR rparen
    (29) EXPR -> EXPR dot identifier lparen . rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    rparen          shift and go to state 117
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 116

state 106

    (19) EXPR -> let identifier colon type . LETHELPER in EXPR
    (20) EXPR -> let identifier colon type . larrow EXPR LETHELPER in EXPR
    (21) LETHELPER -> . comma identifier colon type LETHELPER
    (22) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (23) LETHELPER -> .

    larrow          shift and go to state 119
    comma           shift and go to state 118
    in              reduce using rule 23 (LETHELPER -> .)

    LETHELPER                      shift and go to state 120

state 107

    (14) EXPR -> case EXPR of CASEHELPER . esac
    (16) CASEHELPER -> CASEHELPER . identifier colon type rarrow EXPR semi

    esac            shift and go to state 121
    identifier      shift and go to state 122


state 108

    (15) CASEHELPER -> identifier . colon type rarrow EXPR semi

    colon           shift and go to state 123


state 109

    (25) EXPR -> lbrace EXPR semi rbrace .

    rbrace          reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    at              reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    dot             reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    comma           reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    semi            reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    plus            reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    minus           reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    times           reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    divide          reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    lt              reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    le              reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    equals          reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    rparen          reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    then            reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    of              reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    loop            reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    else            reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    pool            reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    fi              reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)
    in              reduce using rule 25 (EXPR -> lbrace EXPR semi rbrace .)


state 110

    (31) EXPR -> while EXPR loop EXPR . pool
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    pool            shift and go to state 124
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 111

    (27) EXPR -> identifier lparen EXPR rparen .

    rbrace          reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    at              reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    dot             reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    comma           reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    semi            reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    plus            reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    minus           reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    times           reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    divide          reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    lt              reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    le              reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    equals          reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    rparen          reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    then            reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    of              reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    loop            reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    else            reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    pool            reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    fi              reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)
    in              reduce using rule 27 (EXPR -> identifier lparen EXPR rparen .)


state 112

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 8 (FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .)


state 113

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR . rbrace
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 125
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 114

    (30) EXPR -> if EXPR then EXPR else . EXPR fi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 126

state 115

    (17) EXPR -> EXPR at type dot identifier . lparen EXPR rparen
    (28) EXPR -> EXPR at type dot identifier . lparen rparen

    lparen          shift and go to state 127


state 116

    (18) EXPR -> EXPR dot identifier lparen EXPR . rparen
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 128
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 117

    (29) EXPR -> EXPR dot identifier lparen rparen .

    rbrace          reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    at              reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    dot             reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    comma           reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    semi            reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    plus            reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    minus           reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    times           reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    divide          reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    lt              reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    le              reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    equals          reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    rparen          reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    then            reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    of              reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    loop            reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    else            reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    pool            reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    fi              reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)
    in              reduce using rule 29 (EXPR -> EXPR dot identifier lparen rparen .)


state 118

    (21) LETHELPER -> comma . identifier colon type LETHELPER
    (22) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER

    identifier      shift and go to state 129


state 119

    (20) EXPR -> let identifier colon type larrow . EXPR LETHELPER in EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 130

state 120

    (19) EXPR -> let identifier colon type LETHELPER . in EXPR

    in              shift and go to state 131


state 121

    (14) EXPR -> case EXPR of CASEHELPER esac .

    rbrace          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    at              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    dot             reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    comma           reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    semi            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    plus            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    minus           reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    times           reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    divide          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    lt              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    le              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    equals          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    rparen          reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    then            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    of              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    loop            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    else            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    pool            reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    fi              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)
    in              reduce using rule 14 (EXPR -> case EXPR of CASEHELPER esac .)


state 122

    (16) CASEHELPER -> CASEHELPER identifier . colon type rarrow EXPR semi

    colon           shift and go to state 132


state 123

    (15) CASEHELPER -> identifier colon . type rarrow EXPR semi

    type            shift and go to state 133


state 124

    (31) EXPR -> while EXPR loop EXPR pool .

    rbrace          reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    at              reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    dot             reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    comma           reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    semi            reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    plus            reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    minus           reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    times           reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    divide          reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    lt              reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    le              reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    equals          reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    rparen          reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    then            reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    of              reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    loop            reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    else            reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    pool            reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    fi              reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)
    in              reduce using rule 31 (EXPR -> while EXPR loop EXPR pool .)


state 125

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 7 (FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .)


state 126

    (30) EXPR -> if EXPR then EXPR else EXPR . fi
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    fi              shift and go to state 134
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 127

    (17) EXPR -> EXPR at type dot identifier lparen . EXPR rparen
    (28) EXPR -> EXPR at type dot identifier lparen . rparen
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    rparen          shift and go to state 136
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 135

state 128

    (18) EXPR -> EXPR dot identifier lparen EXPR rparen .

    rbrace          reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    at              reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    dot             reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    comma           reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    semi            reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    plus            reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    minus           reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    times           reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    divide          reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    lt              reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    le              reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    equals          reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    then            reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    of              reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    loop            reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    else            reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    pool            reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    fi              reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    in              reduce using rule 18 (EXPR -> EXPR dot identifier lparen EXPR rparen .)


state 129

    (21) LETHELPER -> comma identifier . colon type LETHELPER
    (22) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER

    colon           shift and go to state 137


state 130

    (20) EXPR -> let identifier colon type larrow EXPR . LETHELPER in EXPR
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR
    (21) LETHELPER -> . comma identifier colon type LETHELPER
    (22) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (23) LETHELPER -> .

    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 138
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59
    in              reduce using rule 23 (LETHELPER -> .)

    LETHELPER                      shift and go to state 139

state 131

    (19) EXPR -> let identifier colon type LETHELPER in . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 140

state 132

    (16) CASEHELPER -> CASEHELPER identifier colon . type rarrow EXPR semi

    type            shift and go to state 141


state 133

    (15) CASEHELPER -> identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 142


state 134

    (30) EXPR -> if EXPR then EXPR else EXPR fi .

    rbrace          reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    at              reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    dot             reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    comma           reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    semi            reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    plus            reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    minus           reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    times           reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    divide          reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    lt              reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    le              reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    equals          reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rparen          reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    then            reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    of              reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    loop            reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    else            reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    pool            reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    fi              reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)
    in              reduce using rule 30 (EXPR -> if EXPR then EXPR else EXPR fi .)


state 135

    (17) EXPR -> EXPR at type dot identifier lparen EXPR . rparen
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 143
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 136

    (28) EXPR -> EXPR at type dot identifier lparen rparen .

    rbrace          reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    at              reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    dot             reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    comma           reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    semi            reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    plus            reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    minus           reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    times           reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    divide          reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    lt              reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    le              reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    equals          reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rparen          reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    then            reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    of              reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    loop            reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    else            reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    pool            reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    fi              reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)
    in              reduce using rule 28 (EXPR -> EXPR at type dot identifier lparen rparen .)


state 137

    (21) LETHELPER -> comma identifier colon . type LETHELPER
    (22) LETHELPER -> comma identifier colon . type larrow EXPR LETHELPER

    type            shift and go to state 144


state 138

    (32) EXPR -> EXPR comma . EXPR
    (21) LETHELPER -> comma . identifier colon type LETHELPER
    (22) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    identifier      shift and go to state 145
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 89

state 139

    (20) EXPR -> let identifier colon type larrow EXPR LETHELPER . in EXPR

    in              shift and go to state 146


state 140

    (19) EXPR -> let identifier colon type LETHELPER in EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rparen          reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    then            reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    of              reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    loop            reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    else            reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    pool            reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    fi              reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    in              reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! at              [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 19 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]


state 141

    (16) CASEHELPER -> CASEHELPER identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 147


state 142

    (15) CASEHELPER -> identifier colon type rarrow . EXPR semi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 148

state 143

    (17) EXPR -> EXPR at type dot identifier lparen EXPR rparen .

    rbrace          reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    at              reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    dot             reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    comma           reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    semi            reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    plus            reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    minus           reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    times           reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    divide          reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    lt              reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    le              reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    equals          reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    then            reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    of              reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    loop            reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    else            reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    pool            reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    fi              reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    in              reduce using rule 17 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)


state 144

    (21) LETHELPER -> comma identifier colon type . LETHELPER
    (22) LETHELPER -> comma identifier colon type . larrow EXPR LETHELPER
    (21) LETHELPER -> . comma identifier colon type LETHELPER
    (22) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (23) LETHELPER -> .

    larrow          shift and go to state 149
    comma           shift and go to state 118
    in              reduce using rule 23 (LETHELPER -> .)

    LETHELPER                      shift and go to state 150

state 145

    (21) LETHELPER -> comma identifier . colon type LETHELPER
    (22) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER
    (26) EXPR -> identifier . larrow EXPR
    (27) EXPR -> identifier . lparen EXPR rparen
    (44) EXPR -> identifier .
    (49) EXPR -> identifier . lparen rparen

    colon           shift and go to state 137
    larrow          shift and go to state 75
    lparen          shift and go to state 76
    at              reduce using rule 44 (EXPR -> identifier .)
    dot             reduce using rule 44 (EXPR -> identifier .)
    comma           reduce using rule 44 (EXPR -> identifier .)
    semi            reduce using rule 44 (EXPR -> identifier .)
    plus            reduce using rule 44 (EXPR -> identifier .)
    minus           reduce using rule 44 (EXPR -> identifier .)
    times           reduce using rule 44 (EXPR -> identifier .)
    divide          reduce using rule 44 (EXPR -> identifier .)
    lt              reduce using rule 44 (EXPR -> identifier .)
    le              reduce using rule 44 (EXPR -> identifier .)
    equals          reduce using rule 44 (EXPR -> identifier .)
    in              reduce using rule 44 (EXPR -> identifier .)


state 146

    (20) EXPR -> let identifier colon type larrow EXPR LETHELPER in . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 151

state 147

    (16) CASEHELPER -> CASEHELPER identifier colon type rarrow . EXPR semi
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 152

state 148

    (15) CASEHELPER -> identifier colon type rarrow EXPR . semi
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 153
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 149

    (22) LETHELPER -> comma identifier colon type larrow . EXPR LETHELPER
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

    EXPR                           shift and go to state 154

state 150

    (21) LETHELPER -> comma identifier colon type LETHELPER .

    in              reduce using rule 21 (LETHELPER -> comma identifier colon type LETHELPER .)


state 151

    (20) EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rparen          reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    then            reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    of              reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    loop            reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    else            reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    pool            reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    fi              reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    in              reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59

  ! at              [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 20 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]


state 152

    (16) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR . semi
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 155
    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 64
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59


state 153

    (15) CASEHELPER -> identifier colon type rarrow EXPR semi .
    (33) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 15 (CASEHELPER -> identifier colon type rarrow EXPR semi .)
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

  ! identifier      [ reduce using rule 15 (CASEHELPER -> identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 83

state 154

    (22) LETHELPER -> comma identifier colon type larrow EXPR . LETHELPER
    (17) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (18) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (28) EXPR -> EXPR . at type dot identifier lparen rparen
    (29) EXPR -> EXPR . dot identifier lparen rparen
    (32) EXPR -> EXPR . comma EXPR
    (33) EXPR -> EXPR . semi EXPR
    (37) EXPR -> EXPR . plus EXPR
    (38) EXPR -> EXPR . minus EXPR
    (39) EXPR -> EXPR . times EXPR
    (40) EXPR -> EXPR . divide EXPR
    (41) EXPR -> EXPR . lt EXPR
    (42) EXPR -> EXPR . le EXPR
    (43) EXPR -> EXPR . equals EXPR
    (21) LETHELPER -> . comma identifier colon type LETHELPER
    (22) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (23) LETHELPER -> .

    at              shift and go to state 63
    dot             shift and go to state 66
    comma           shift and go to state 138
    semi            shift and go to state 58
    plus            shift and go to state 56
    minus           shift and go to state 65
    times           shift and go to state 60
    divide          shift and go to state 57
    lt              shift and go to state 61
    le              shift and go to state 62
    equals          shift and go to state 59
    in              reduce using rule 23 (LETHELPER -> .)

    LETHELPER                      shift and go to state 156

state 155

    (16) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .
    (33) EXPR -> EXPR semi . EXPR
    (14) EXPR -> . case EXPR of CASEHELPER esac
    (17) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (18) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (19) EXPR -> . let identifier colon type LETHELPER in EXPR
    (20) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (24) EXPR -> . lparen EXPR rparen
    (25) EXPR -> . lbrace EXPR semi rbrace
    (26) EXPR -> . identifier larrow EXPR
    (27) EXPR -> . identifier lparen EXPR rparen
    (28) EXPR -> . EXPR at type dot identifier lparen rparen
    (29) EXPR -> . EXPR dot identifier lparen rparen
    (30) EXPR -> . if EXPR then EXPR else EXPR fi
    (31) EXPR -> . while EXPR loop EXPR pool
    (32) EXPR -> . EXPR comma EXPR
    (33) EXPR -> . EXPR semi EXPR
    (34) EXPR -> . isvoid EXPR
    (35) EXPR -> . tilde EXPR
    (36) EXPR -> . not EXPR
    (37) EXPR -> . EXPR plus EXPR
    (38) EXPR -> . EXPR minus EXPR
    (39) EXPR -> . EXPR times EXPR
    (40) EXPR -> . EXPR divide EXPR
    (41) EXPR -> . EXPR lt EXPR
    (42) EXPR -> . EXPR le EXPR
    (43) EXPR -> . EXPR equals EXPR
    (44) EXPR -> . identifier
    (45) EXPR -> . integer
    (46) EXPR -> . string
    (47) EXPR -> . true
    (48) EXPR -> . false
    (49) EXPR -> . identifier lparen rparen
    (50) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 16 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .)
    case            shift and go to state 46
    let             shift and go to state 41
    lparen          shift and go to state 42
    lbrace          shift and go to state 47
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 48
    isvoid          shift and go to state 39
    tilde           shift and go to state 35
    not             shift and go to state 44
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 45
    false           shift and go to state 34
    new             shift and go to state 43

  ! identifier      [ reduce using rule 16 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 83

state 156

    (22) LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .

    in              reduce using rule 22 (LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for semi in state 21 resolved as shift
WARNING: shift/reduce conflict for at in state 83 resolved as shift
WARNING: shift/reduce conflict for dot in state 83 resolved as shift
WARNING: shift/reduce conflict for comma in state 83 resolved as shift
WARNING: shift/reduce conflict for semi in state 83 resolved as shift
WARNING: shift/reduce conflict for plus in state 83 resolved as shift
WARNING: shift/reduce conflict for minus in state 83 resolved as shift
WARNING: shift/reduce conflict for times in state 83 resolved as shift
WARNING: shift/reduce conflict for divide in state 83 resolved as shift
WARNING: shift/reduce conflict for lt in state 83 resolved as shift
WARNING: shift/reduce conflict for le in state 83 resolved as shift
WARNING: shift/reduce conflict for equals in state 83 resolved as shift
WARNING: shift/reduce conflict for at in state 89 resolved as shift
WARNING: shift/reduce conflict for dot in state 89 resolved as shift
WARNING: shift/reduce conflict for comma in state 89 resolved as shift
WARNING: shift/reduce conflict for semi in state 89 resolved as shift
WARNING: shift/reduce conflict for plus in state 89 resolved as shift
WARNING: shift/reduce conflict for minus in state 89 resolved as shift
WARNING: shift/reduce conflict for times in state 89 resolved as shift
WARNING: shift/reduce conflict for divide in state 89 resolved as shift
WARNING: shift/reduce conflict for lt in state 89 resolved as shift
WARNING: shift/reduce conflict for le in state 89 resolved as shift
WARNING: shift/reduce conflict for equals in state 89 resolved as shift
WARNING: shift/reduce conflict for at in state 140 resolved as shift
WARNING: shift/reduce conflict for dot in state 140 resolved as shift
WARNING: shift/reduce conflict for comma in state 140 resolved as shift
WARNING: shift/reduce conflict for semi in state 140 resolved as shift
WARNING: shift/reduce conflict for plus in state 140 resolved as shift
WARNING: shift/reduce conflict for minus in state 140 resolved as shift
WARNING: shift/reduce conflict for times in state 140 resolved as shift
WARNING: shift/reduce conflict for divide in state 140 resolved as shift
WARNING: shift/reduce conflict for lt in state 140 resolved as shift
WARNING: shift/reduce conflict for le in state 140 resolved as shift
WARNING: shift/reduce conflict for equals in state 140 resolved as shift
WARNING: shift/reduce conflict for at in state 151 resolved as shift
WARNING: shift/reduce conflict for dot in state 151 resolved as shift
WARNING: shift/reduce conflict for comma in state 151 resolved as shift
WARNING: shift/reduce conflict for semi in state 151 resolved as shift
WARNING: shift/reduce conflict for plus in state 151 resolved as shift
WARNING: shift/reduce conflict for minus in state 151 resolved as shift
WARNING: shift/reduce conflict for times in state 151 resolved as shift
WARNING: shift/reduce conflict for divide in state 151 resolved as shift
WARNING: shift/reduce conflict for lt in state 151 resolved as shift
WARNING: shift/reduce conflict for le in state 151 resolved as shift
WARNING: shift/reduce conflict for equals in state 151 resolved as shift
WARNING: shift/reduce conflict for identifier in state 153 resolved as shift
WARNING: shift/reduce conflict for identifier in state 155 resolved as shift
