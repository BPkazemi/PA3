Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> START
Rule 1     START -> PROGRAM
Rule 2     PROGRAM -> PROGRAM CLASSDEF semi
Rule 3     PROGRAM -> CLASSDEF semi
Rule 4     CLASSDEF -> class type lbrace rbrace
Rule 5     CLASSDEF -> class type lbrace FEATURE semi rbrace
Rule 6     CLASSDEF -> class type inherits type lbrace rbrace
Rule 7     CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace
Rule 8     FEATURE -> FEATURE semi FEATURELIT
Rule 9     FEATURE -> FEATURELIT
Rule 10    FEATURELIT -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
Rule 11    FEATURELIT -> identifier lparen rparen colon type lbrace EXPR rbrace
Rule 12    FEATURELIT -> identifier colon type
Rule 13    FEATURELIT -> identifier colon type larrow EXPR
Rule 14    FORMAL -> FORMAL comma FORMALLIT
Rule 15    FORMAL -> FORMALLIT
Rule 16    FORMALLIT -> identifier colon type
Rule 17    EXPR -> case EXPR of CASEHELPER esac
Rule 18    CASEHELPER -> CASEHELPER CASELIT
Rule 19    CASEHELPER -> CASELIT
Rule 20    CASELIT -> identifier colon type rarrow EXPR semi
Rule 21    EXPR -> EXPR at type dot identifier lparen rparen
Rule 22    EXPR -> EXPR dot identifier lparen rparen
Rule 23    EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
Rule 24    EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen
Rule 25    EXPR -> let identifier colon type LETHELPER in EXPR
Rule 26    EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR
Rule 27    EXPR -> let identifier colon type in EXPR
Rule 28    EXPR -> let identifier colon type larrow EXPR in EXPR
Rule 29    LETHELPER -> comma LETHELPERLIT LETHELPER
Rule 30    LETHELPER -> comma LETHELPERLIT
Rule 31    LETHELPERLIT -> identifier colon type
Rule 32    LETHELPERLIT -> identifier colon type larrow EXPR
Rule 33    EXPR -> lparen EXPR rparen
Rule 34    EXPR -> lbrace EXPRLISTSEMI semi rbrace
Rule 35    EXPR -> identifier lparen rparen
Rule 36    EXPR -> identifier lparen EXPRLISTCOMMA rparen
Rule 37    EXPR -> identifier larrow EXPR
Rule 38    EXPR -> if EXPR then EXPR else EXPR fi
Rule 39    EXPR -> while EXPR loop EXPR pool
Rule 40    EXPRLISTCOMMA -> EXPRLISTCOMMA comma EXPR
Rule 41    EXPRLISTCOMMA -> EXPR
Rule 42    EXPRLISTSEMI -> EXPRLISTSEMI semi EXPR
Rule 43    EXPRLISTSEMI -> EXPR
Rule 44    EXPR -> isvoid EXPR
Rule 45    EXPR -> tilde EXPR
Rule 46    EXPR -> not EXPR
Rule 47    EXPR -> EXPR plus EXPR
Rule 48    EXPR -> EXPR minus EXPR
Rule 49    EXPR -> EXPR times EXPR
Rule 50    EXPR -> EXPR divide EXPR
Rule 51    EXPR -> EXPR lt EXPR
Rule 52    EXPR -> EXPR le EXPR
Rule 53    EXPR -> EXPR equals EXPR
Rule 54    EXPR -> identifier
Rule 55    EXPR -> integer
Rule 56    EXPR -> string
Rule 57    EXPR -> true
Rule 58    EXPR -> false
Rule 59    EXPR -> new type

Terminals, with rules where they appear

at                   : 21 23
case                 : 17
class                : 4 5 6 7
colon                : 10 11 12 13 16 20 25 26 27 28 31 32
comma                : 14 29 30 40
divide               : 50
dot                  : 21 22 23 24
else                 : 38
equals               : 53
error                : 
esac                 : 17
false                : 58
fi                   : 38
identifier           : 10 11 12 13 16 20 21 22 23 24 25 26 27 28 31 32 35 36 37 54
if                   : 38
in                   : 25 26 27 28
inherits             : 6 7
integer              : 55
isvoid               : 44
larrow               : 13 26 28 32 37
lbrace               : 4 5 6 7 10 11 34
le                   : 52
let                  : 25 26 27 28
loop                 : 39
lparen               : 10 11 21 22 23 24 33 35 36
lt                   : 51
minus                : 48
new                  : 59
not                  : 46
of                   : 17
plus                 : 47
pool                 : 39
rarrow               : 20
rbrace               : 4 5 6 7 10 11 34
rparen               : 10 11 21 22 23 24 33 35 36
semi                 : 2 3 5 7 8 20 34 42
string               : 56
then                 : 38
tilde                : 45
times                : 49
true                 : 57
type                 : 4 5 6 6 7 7 10 11 12 13 16 20 21 23 25 26 27 28 31 32 59
while                : 39

Nonterminals, with rules where they appear

CASEHELPER           : 17 18
CASELIT              : 18 19
CLASSDEF             : 2 3
EXPR                 : 10 11 13 17 20 21 22 23 24 25 26 26 27 28 28 32 33 37 38 38 38 39 39 40 41 42 43 44 45 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53
EXPRLISTCOMMA        : 23 24 36 40
EXPRLISTSEMI         : 34 42
FEATURE              : 5 7 8
FEATURELIT           : 8 9
FORMAL               : 10 14
FORMALLIT            : 14 15
LETHELPER            : 25 26 29
LETHELPERLIT         : 29 30
PROGRAM              : 1 2
START                : 0

Parsing method: LALR

state 0

    (0) S' -> . START
    (1) START -> . PROGRAM
    (2) PROGRAM -> . PROGRAM CLASSDEF semi
    (3) PROGRAM -> . CLASSDEF semi
    (4) CLASSDEF -> . class type lbrace rbrace
    (5) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (6) CLASSDEF -> . class type inherits type lbrace rbrace
    (7) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 4

    START                          shift and go to state 2
    PROGRAM                        shift and go to state 3
    CLASSDEF                       shift and go to state 1

state 1

    (3) PROGRAM -> CLASSDEF . semi

    semi            shift and go to state 5


state 2

    (0) S' -> START .



state 3

    (1) START -> PROGRAM .
    (2) PROGRAM -> PROGRAM . CLASSDEF semi
    (4) CLASSDEF -> . class type lbrace rbrace
    (5) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (6) CLASSDEF -> . class type inherits type lbrace rbrace
    (7) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    $end            reduce using rule 1 (START -> PROGRAM .)
    class           shift and go to state 4

    CLASSDEF                       shift and go to state 6

state 4

    (4) CLASSDEF -> class . type lbrace rbrace
    (5) CLASSDEF -> class . type lbrace FEATURE semi rbrace
    (6) CLASSDEF -> class . type inherits type lbrace rbrace
    (7) CLASSDEF -> class . type inherits type lbrace FEATURE semi rbrace

    type            shift and go to state 7


state 5

    (3) PROGRAM -> CLASSDEF semi .

    class           reduce using rule 3 (PROGRAM -> CLASSDEF semi .)
    $end            reduce using rule 3 (PROGRAM -> CLASSDEF semi .)


state 6

    (2) PROGRAM -> PROGRAM CLASSDEF . semi

    semi            shift and go to state 8


state 7

    (4) CLASSDEF -> class type . lbrace rbrace
    (5) CLASSDEF -> class type . lbrace FEATURE semi rbrace
    (6) CLASSDEF -> class type . inherits type lbrace rbrace
    (7) CLASSDEF -> class type . inherits type lbrace FEATURE semi rbrace

    lbrace          shift and go to state 10
    inherits        shift and go to state 9


state 8

    (2) PROGRAM -> PROGRAM CLASSDEF semi .

    class           reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)
    $end            reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)


state 9

    (6) CLASSDEF -> class type inherits . type lbrace rbrace
    (7) CLASSDEF -> class type inherits . type lbrace FEATURE semi rbrace

    type            shift and go to state 11


state 10

    (4) CLASSDEF -> class type lbrace . rbrace
    (5) CLASSDEF -> class type lbrace . FEATURE semi rbrace
    (8) FEATURE -> . FEATURE semi FEATURELIT
    (9) FEATURE -> . FEATURELIT
    (10) FEATURELIT -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (11) FEATURELIT -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (12) FEATURELIT -> . identifier colon type
    (13) FEATURELIT -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 12
    identifier      shift and go to state 15

    FEATURELIT                     shift and go to state 14
    FEATURE                        shift and go to state 13

state 11

    (6) CLASSDEF -> class type inherits type . lbrace rbrace
    (7) CLASSDEF -> class type inherits type . lbrace FEATURE semi rbrace

    lbrace          shift and go to state 16


state 12

    (4) CLASSDEF -> class type lbrace rbrace .

    semi            reduce using rule 4 (CLASSDEF -> class type lbrace rbrace .)


state 13

    (5) CLASSDEF -> class type lbrace FEATURE . semi rbrace
    (8) FEATURE -> FEATURE . semi FEATURELIT

    semi            shift and go to state 17


state 14

    (9) FEATURE -> FEATURELIT .

    semi            reduce using rule 9 (FEATURE -> FEATURELIT .)


state 15

    (10) FEATURELIT -> identifier . lparen FORMAL rparen colon type lbrace EXPR rbrace
    (11) FEATURELIT -> identifier . lparen rparen colon type lbrace EXPR rbrace
    (12) FEATURELIT -> identifier . colon type
    (13) FEATURELIT -> identifier . colon type larrow EXPR

    lparen          shift and go to state 19
    colon           shift and go to state 18


state 16

    (6) CLASSDEF -> class type inherits type lbrace . rbrace
    (7) CLASSDEF -> class type inherits type lbrace . FEATURE semi rbrace
    (8) FEATURE -> . FEATURE semi FEATURELIT
    (9) FEATURE -> . FEATURELIT
    (10) FEATURELIT -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (11) FEATURELIT -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (12) FEATURELIT -> . identifier colon type
    (13) FEATURELIT -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 20
    identifier      shift and go to state 15

    FEATURELIT                     shift and go to state 14
    FEATURE                        shift and go to state 21

state 17

    (5) CLASSDEF -> class type lbrace FEATURE semi . rbrace
    (8) FEATURE -> FEATURE semi . FEATURELIT
    (10) FEATURELIT -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (11) FEATURELIT -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (12) FEATURELIT -> . identifier colon type
    (13) FEATURELIT -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 22
    identifier      shift and go to state 15

    FEATURELIT                     shift and go to state 23

state 18

    (12) FEATURELIT -> identifier colon . type
    (13) FEATURELIT -> identifier colon . type larrow EXPR

    type            shift and go to state 24


state 19

    (10) FEATURELIT -> identifier lparen . FORMAL rparen colon type lbrace EXPR rbrace
    (11) FEATURELIT -> identifier lparen . rparen colon type lbrace EXPR rbrace
    (14) FORMAL -> . FORMAL comma FORMALLIT
    (15) FORMAL -> . FORMALLIT
    (16) FORMALLIT -> . identifier colon type

    rparen          shift and go to state 25
    identifier      shift and go to state 27

    FORMALLIT                      shift and go to state 26
    FORMAL                         shift and go to state 28

state 20

    (6) CLASSDEF -> class type inherits type lbrace rbrace .

    semi            reduce using rule 6 (CLASSDEF -> class type inherits type lbrace rbrace .)


state 21

    (7) CLASSDEF -> class type inherits type lbrace FEATURE . semi rbrace
    (8) FEATURE -> FEATURE . semi FEATURELIT

    semi            shift and go to state 29


state 22

    (5) CLASSDEF -> class type lbrace FEATURE semi rbrace .

    semi            reduce using rule 5 (CLASSDEF -> class type lbrace FEATURE semi rbrace .)


state 23

    (8) FEATURE -> FEATURE semi FEATURELIT .

    semi            reduce using rule 8 (FEATURE -> FEATURE semi FEATURELIT .)


state 24

    (12) FEATURELIT -> identifier colon type .
    (13) FEATURELIT -> identifier colon type . larrow EXPR

    semi            reduce using rule 12 (FEATURELIT -> identifier colon type .)
    larrow          shift and go to state 30


state 25

    (11) FEATURELIT -> identifier lparen rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 31


state 26

    (15) FORMAL -> FORMALLIT .

    rparen          reduce using rule 15 (FORMAL -> FORMALLIT .)
    comma           reduce using rule 15 (FORMAL -> FORMALLIT .)


state 27

    (16) FORMALLIT -> identifier . colon type

    colon           shift and go to state 32


state 28

    (10) FEATURELIT -> identifier lparen FORMAL . rparen colon type lbrace EXPR rbrace
    (14) FORMAL -> FORMAL . comma FORMALLIT

    rparen          shift and go to state 33
    comma           shift and go to state 34


state 29

    (7) CLASSDEF -> class type inherits type lbrace FEATURE semi . rbrace
    (8) FEATURE -> FEATURE semi . FEATURELIT
    (10) FEATURELIT -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (11) FEATURELIT -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (12) FEATURELIT -> . identifier colon type
    (13) FEATURELIT -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 35
    identifier      shift and go to state 15

    FEATURELIT                     shift and go to state 23

state 30

    (13) FEATURELIT -> identifier colon type larrow . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 40

state 31

    (11) FEATURELIT -> identifier lparen rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 52


state 32

    (16) FORMALLIT -> identifier colon . type

    type            shift and go to state 53


state 33

    (10) FEATURELIT -> identifier lparen FORMAL rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 54


state 34

    (14) FORMAL -> FORMAL comma . FORMALLIT
    (16) FORMALLIT -> . identifier colon type

    identifier      shift and go to state 27

    FORMALLIT                      shift and go to state 55

state 35

    (7) CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .

    semi            reduce using rule 7 (CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .)


state 36

    (58) EXPR -> false .

    at              reduce using rule 58 (EXPR -> false .)
    dot             reduce using rule 58 (EXPR -> false .)
    plus            reduce using rule 58 (EXPR -> false .)
    minus           reduce using rule 58 (EXPR -> false .)
    times           reduce using rule 58 (EXPR -> false .)
    divide          reduce using rule 58 (EXPR -> false .)
    lt              reduce using rule 58 (EXPR -> false .)
    le              reduce using rule 58 (EXPR -> false .)
    equals          reduce using rule 58 (EXPR -> false .)
    comma           reduce using rule 58 (EXPR -> false .)
    in              reduce using rule 58 (EXPR -> false .)
    rparen          reduce using rule 58 (EXPR -> false .)
    semi            reduce using rule 58 (EXPR -> false .)
    then            reduce using rule 58 (EXPR -> false .)
    of              reduce using rule 58 (EXPR -> false .)
    loop            reduce using rule 58 (EXPR -> false .)
    rbrace          reduce using rule 58 (EXPR -> false .)
    else            reduce using rule 58 (EXPR -> false .)
    pool            reduce using rule 58 (EXPR -> false .)
    fi              reduce using rule 58 (EXPR -> false .)


state 37

    (45) EXPR -> tilde . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 56

state 38

    (38) EXPR -> if . EXPR then EXPR else EXPR fi
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 57

state 39

    (55) EXPR -> integer .

    at              reduce using rule 55 (EXPR -> integer .)
    dot             reduce using rule 55 (EXPR -> integer .)
    plus            reduce using rule 55 (EXPR -> integer .)
    minus           reduce using rule 55 (EXPR -> integer .)
    times           reduce using rule 55 (EXPR -> integer .)
    divide          reduce using rule 55 (EXPR -> integer .)
    lt              reduce using rule 55 (EXPR -> integer .)
    le              reduce using rule 55 (EXPR -> integer .)
    equals          reduce using rule 55 (EXPR -> integer .)
    comma           reduce using rule 55 (EXPR -> integer .)
    in              reduce using rule 55 (EXPR -> integer .)
    rparen          reduce using rule 55 (EXPR -> integer .)
    semi            reduce using rule 55 (EXPR -> integer .)
    then            reduce using rule 55 (EXPR -> integer .)
    of              reduce using rule 55 (EXPR -> integer .)
    loop            reduce using rule 55 (EXPR -> integer .)
    rbrace          reduce using rule 55 (EXPR -> integer .)
    else            reduce using rule 55 (EXPR -> integer .)
    pool            reduce using rule 55 (EXPR -> integer .)
    fi              reduce using rule 55 (EXPR -> integer .)


state 40

    (13) FEATURELIT -> identifier colon type larrow EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 13 (FEATURELIT -> identifier colon type larrow EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 41

    (44) EXPR -> isvoid . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 67

state 42

    (56) EXPR -> string .

    at              reduce using rule 56 (EXPR -> string .)
    dot             reduce using rule 56 (EXPR -> string .)
    plus            reduce using rule 56 (EXPR -> string .)
    minus           reduce using rule 56 (EXPR -> string .)
    times           reduce using rule 56 (EXPR -> string .)
    divide          reduce using rule 56 (EXPR -> string .)
    lt              reduce using rule 56 (EXPR -> string .)
    le              reduce using rule 56 (EXPR -> string .)
    equals          reduce using rule 56 (EXPR -> string .)
    comma           reduce using rule 56 (EXPR -> string .)
    in              reduce using rule 56 (EXPR -> string .)
    rparen          reduce using rule 56 (EXPR -> string .)
    semi            reduce using rule 56 (EXPR -> string .)
    then            reduce using rule 56 (EXPR -> string .)
    of              reduce using rule 56 (EXPR -> string .)
    loop            reduce using rule 56 (EXPR -> string .)
    rbrace          reduce using rule 56 (EXPR -> string .)
    else            reduce using rule 56 (EXPR -> string .)
    pool            reduce using rule 56 (EXPR -> string .)
    fi              reduce using rule 56 (EXPR -> string .)


state 43

    (25) EXPR -> let . identifier colon type LETHELPER in EXPR
    (26) EXPR -> let . identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> let . identifier colon type in EXPR
    (28) EXPR -> let . identifier colon type larrow EXPR in EXPR

    identifier      shift and go to state 68


state 44

    (33) EXPR -> lparen . EXPR rparen
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 69

state 45

    (59) EXPR -> new . type

    type            shift and go to state 70


state 46

    (46) EXPR -> not . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 71

state 47

    (57) EXPR -> true .

    at              reduce using rule 57 (EXPR -> true .)
    dot             reduce using rule 57 (EXPR -> true .)
    plus            reduce using rule 57 (EXPR -> true .)
    minus           reduce using rule 57 (EXPR -> true .)
    times           reduce using rule 57 (EXPR -> true .)
    divide          reduce using rule 57 (EXPR -> true .)
    lt              reduce using rule 57 (EXPR -> true .)
    le              reduce using rule 57 (EXPR -> true .)
    equals          reduce using rule 57 (EXPR -> true .)
    comma           reduce using rule 57 (EXPR -> true .)
    in              reduce using rule 57 (EXPR -> true .)
    rparen          reduce using rule 57 (EXPR -> true .)
    semi            reduce using rule 57 (EXPR -> true .)
    then            reduce using rule 57 (EXPR -> true .)
    of              reduce using rule 57 (EXPR -> true .)
    loop            reduce using rule 57 (EXPR -> true .)
    rbrace          reduce using rule 57 (EXPR -> true .)
    else            reduce using rule 57 (EXPR -> true .)
    pool            reduce using rule 57 (EXPR -> true .)
    fi              reduce using rule 57 (EXPR -> true .)


state 48

    (17) EXPR -> case . EXPR of CASEHELPER esac
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 72

state 49

    (34) EXPR -> lbrace . EXPRLISTSEMI semi rbrace
    (42) EXPRLISTSEMI -> . EXPRLISTSEMI semi EXPR
    (43) EXPRLISTSEMI -> . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 73
    EXPRLISTSEMI                   shift and go to state 74

state 50

    (39) EXPR -> while . EXPR loop EXPR pool
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 75

state 51

    (35) EXPR -> identifier . lparen rparen
    (36) EXPR -> identifier . lparen EXPRLISTCOMMA rparen
    (37) EXPR -> identifier . larrow EXPR
    (54) EXPR -> identifier .

    lparen          shift and go to state 77
    larrow          shift and go to state 76
    at              reduce using rule 54 (EXPR -> identifier .)
    dot             reduce using rule 54 (EXPR -> identifier .)
    plus            reduce using rule 54 (EXPR -> identifier .)
    minus           reduce using rule 54 (EXPR -> identifier .)
    times           reduce using rule 54 (EXPR -> identifier .)
    divide          reduce using rule 54 (EXPR -> identifier .)
    lt              reduce using rule 54 (EXPR -> identifier .)
    le              reduce using rule 54 (EXPR -> identifier .)
    equals          reduce using rule 54 (EXPR -> identifier .)
    comma           reduce using rule 54 (EXPR -> identifier .)
    in              reduce using rule 54 (EXPR -> identifier .)
    rparen          reduce using rule 54 (EXPR -> identifier .)
    semi            reduce using rule 54 (EXPR -> identifier .)
    then            reduce using rule 54 (EXPR -> identifier .)
    of              reduce using rule 54 (EXPR -> identifier .)
    loop            reduce using rule 54 (EXPR -> identifier .)
    rbrace          reduce using rule 54 (EXPR -> identifier .)
    else            reduce using rule 54 (EXPR -> identifier .)
    pool            reduce using rule 54 (EXPR -> identifier .)
    fi              reduce using rule 54 (EXPR -> identifier .)


state 52

    (11) FEATURELIT -> identifier lparen rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 78


state 53

    (16) FORMALLIT -> identifier colon type .

    rparen          reduce using rule 16 (FORMALLIT -> identifier colon type .)
    comma           reduce using rule 16 (FORMALLIT -> identifier colon type .)


state 54

    (10) FEATURELIT -> identifier lparen FORMAL rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 79


state 55

    (14) FORMAL -> FORMAL comma FORMALLIT .

    rparen          reduce using rule 14 (FORMAL -> FORMAL comma FORMALLIT .)
    comma           reduce using rule 14 (FORMAL -> FORMAL comma FORMALLIT .)


state 56

    (45) EXPR -> tilde EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    plus            reduce using rule 45 (EXPR -> tilde EXPR .)
    minus           reduce using rule 45 (EXPR -> tilde EXPR .)
    times           reduce using rule 45 (EXPR -> tilde EXPR .)
    divide          reduce using rule 45 (EXPR -> tilde EXPR .)
    lt              reduce using rule 45 (EXPR -> tilde EXPR .)
    le              reduce using rule 45 (EXPR -> tilde EXPR .)
    equals          reduce using rule 45 (EXPR -> tilde EXPR .)
    comma           reduce using rule 45 (EXPR -> tilde EXPR .)
    in              reduce using rule 45 (EXPR -> tilde EXPR .)
    rparen          reduce using rule 45 (EXPR -> tilde EXPR .)
    semi            reduce using rule 45 (EXPR -> tilde EXPR .)
    then            reduce using rule 45 (EXPR -> tilde EXPR .)
    of              reduce using rule 45 (EXPR -> tilde EXPR .)
    loop            reduce using rule 45 (EXPR -> tilde EXPR .)
    rbrace          reduce using rule 45 (EXPR -> tilde EXPR .)
    else            reduce using rule 45 (EXPR -> tilde EXPR .)
    pool            reduce using rule 45 (EXPR -> tilde EXPR .)
    fi              reduce using rule 45 (EXPR -> tilde EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 45 (EXPR -> tilde EXPR .) ]
  ! dot             [ reduce using rule 45 (EXPR -> tilde EXPR .) ]
  ! plus            [ shift and go to state 64 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 59 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 57

    (38) EXPR -> if EXPR . then EXPR else EXPR fi
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    then            shift and go to state 80
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 58

    (52) EXPR -> EXPR le . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 81

state 59

    (50) EXPR -> EXPR divide . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 82

state 60

    (53) EXPR -> EXPR equals . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 83

state 61

    (49) EXPR -> EXPR times . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 84

state 62

    (51) EXPR -> EXPR lt . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 85

state 63

    (21) EXPR -> EXPR at . type dot identifier lparen rparen
    (23) EXPR -> EXPR at . type dot identifier lparen EXPRLISTCOMMA rparen

    type            shift and go to state 86


state 64

    (47) EXPR -> EXPR plus . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 87

state 65

    (48) EXPR -> EXPR minus . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 88

state 66

    (22) EXPR -> EXPR dot . identifier lparen rparen
    (24) EXPR -> EXPR dot . identifier lparen EXPRLISTCOMMA rparen

    identifier      shift and go to state 89


state 67

    (44) EXPR -> isvoid EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    plus            reduce using rule 44 (EXPR -> isvoid EXPR .)
    minus           reduce using rule 44 (EXPR -> isvoid EXPR .)
    times           reduce using rule 44 (EXPR -> isvoid EXPR .)
    divide          reduce using rule 44 (EXPR -> isvoid EXPR .)
    lt              reduce using rule 44 (EXPR -> isvoid EXPR .)
    le              reduce using rule 44 (EXPR -> isvoid EXPR .)
    equals          reduce using rule 44 (EXPR -> isvoid EXPR .)
    comma           reduce using rule 44 (EXPR -> isvoid EXPR .)
    in              reduce using rule 44 (EXPR -> isvoid EXPR .)
    rparen          reduce using rule 44 (EXPR -> isvoid EXPR .)
    semi            reduce using rule 44 (EXPR -> isvoid EXPR .)
    then            reduce using rule 44 (EXPR -> isvoid EXPR .)
    of              reduce using rule 44 (EXPR -> isvoid EXPR .)
    loop            reduce using rule 44 (EXPR -> isvoid EXPR .)
    rbrace          reduce using rule 44 (EXPR -> isvoid EXPR .)
    else            reduce using rule 44 (EXPR -> isvoid EXPR .)
    pool            reduce using rule 44 (EXPR -> isvoid EXPR .)
    fi              reduce using rule 44 (EXPR -> isvoid EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 44 (EXPR -> isvoid EXPR .) ]
  ! dot             [ reduce using rule 44 (EXPR -> isvoid EXPR .) ]
  ! plus            [ shift and go to state 64 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 59 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 68

    (25) EXPR -> let identifier . colon type LETHELPER in EXPR
    (26) EXPR -> let identifier . colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> let identifier . colon type in EXPR
    (28) EXPR -> let identifier . colon type larrow EXPR in EXPR

    colon           shift and go to state 90


state 69

    (33) EXPR -> lparen EXPR . rparen
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 91
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 70

    (59) EXPR -> new type .

    at              reduce using rule 59 (EXPR -> new type .)
    dot             reduce using rule 59 (EXPR -> new type .)
    plus            reduce using rule 59 (EXPR -> new type .)
    minus           reduce using rule 59 (EXPR -> new type .)
    times           reduce using rule 59 (EXPR -> new type .)
    divide          reduce using rule 59 (EXPR -> new type .)
    lt              reduce using rule 59 (EXPR -> new type .)
    le              reduce using rule 59 (EXPR -> new type .)
    equals          reduce using rule 59 (EXPR -> new type .)
    comma           reduce using rule 59 (EXPR -> new type .)
    in              reduce using rule 59 (EXPR -> new type .)
    rparen          reduce using rule 59 (EXPR -> new type .)
    semi            reduce using rule 59 (EXPR -> new type .)
    then            reduce using rule 59 (EXPR -> new type .)
    of              reduce using rule 59 (EXPR -> new type .)
    loop            reduce using rule 59 (EXPR -> new type .)
    rbrace          reduce using rule 59 (EXPR -> new type .)
    else            reduce using rule 59 (EXPR -> new type .)
    pool            reduce using rule 59 (EXPR -> new type .)
    fi              reduce using rule 59 (EXPR -> new type .)


state 71

    (46) EXPR -> not EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 46 (EXPR -> not EXPR .)
    in              reduce using rule 46 (EXPR -> not EXPR .)
    rparen          reduce using rule 46 (EXPR -> not EXPR .)
    semi            reduce using rule 46 (EXPR -> not EXPR .)
    then            reduce using rule 46 (EXPR -> not EXPR .)
    of              reduce using rule 46 (EXPR -> not EXPR .)
    loop            reduce using rule 46 (EXPR -> not EXPR .)
    rbrace          reduce using rule 46 (EXPR -> not EXPR .)
    else            reduce using rule 46 (EXPR -> not EXPR .)
    pool            reduce using rule 46 (EXPR -> not EXPR .)
    fi              reduce using rule 46 (EXPR -> not EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

  ! at              [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! dot             [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! plus            [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! minus           [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! times           [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! divide          [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! lt              [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! le              [ reduce using rule 46 (EXPR -> not EXPR .) ]
  ! equals          [ reduce using rule 46 (EXPR -> not EXPR .) ]


state 72

    (17) EXPR -> case EXPR . of CASEHELPER esac
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    of              shift and go to state 92
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 73

    (43) EXPRLISTSEMI -> EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 43 (EXPRLISTSEMI -> EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 74

    (34) EXPR -> lbrace EXPRLISTSEMI . semi rbrace
    (42) EXPRLISTSEMI -> EXPRLISTSEMI . semi EXPR

    semi            shift and go to state 93


state 75

    (39) EXPR -> while EXPR . loop EXPR pool
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    loop            shift and go to state 94
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 76

    (37) EXPR -> identifier larrow . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 95

state 77

    (35) EXPR -> identifier lparen . rparen
    (36) EXPR -> identifier lparen . EXPRLISTCOMMA rparen
    (40) EXPRLISTCOMMA -> . EXPRLISTCOMMA comma EXPR
    (41) EXPRLISTCOMMA -> . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    rparen          shift and go to state 98
    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 97
    EXPRLISTCOMMA                  shift and go to state 96

state 78

    (11) FEATURELIT -> identifier lparen rparen colon type lbrace . EXPR rbrace
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 99

state 79

    (10) FEATURELIT -> identifier lparen FORMAL rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 100


state 80

    (38) EXPR -> if EXPR then . EXPR else EXPR fi
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 101

state 81

    (52) EXPR -> EXPR le EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    lt              reduce using rule 52 (EXPR -> EXPR le EXPR .)
    le              reduce using rule 52 (EXPR -> EXPR le EXPR .)
    equals          reduce using rule 52 (EXPR -> EXPR le EXPR .)
    comma           reduce using rule 52 (EXPR -> EXPR le EXPR .)
    in              reduce using rule 52 (EXPR -> EXPR le EXPR .)
    rparen          reduce using rule 52 (EXPR -> EXPR le EXPR .)
    semi            reduce using rule 52 (EXPR -> EXPR le EXPR .)
    then            reduce using rule 52 (EXPR -> EXPR le EXPR .)
    of              reduce using rule 52 (EXPR -> EXPR le EXPR .)
    loop            reduce using rule 52 (EXPR -> EXPR le EXPR .)
    rbrace          reduce using rule 52 (EXPR -> EXPR le EXPR .)
    else            reduce using rule 52 (EXPR -> EXPR le EXPR .)
    pool            reduce using rule 52 (EXPR -> EXPR le EXPR .)
    fi              reduce using rule 52 (EXPR -> EXPR le EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59

  ! at              [ reduce using rule 52 (EXPR -> EXPR le EXPR .) ]
  ! dot             [ reduce using rule 52 (EXPR -> EXPR le EXPR .) ]
  ! plus            [ reduce using rule 52 (EXPR -> EXPR le EXPR .) ]
  ! minus           [ reduce using rule 52 (EXPR -> EXPR le EXPR .) ]
  ! times           [ reduce using rule 52 (EXPR -> EXPR le EXPR .) ]
  ! divide          [ reduce using rule 52 (EXPR -> EXPR le EXPR .) ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 82

    (50) EXPR -> EXPR divide EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    plus            reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    lt              reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    le              reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    comma           reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    in              reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    rparen          reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    semi            reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    then            reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    of              reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    loop            reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    rbrace          reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    pool            reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    fi              reduce using rule 50 (EXPR -> EXPR divide EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 50 (EXPR -> EXPR divide EXPR .) ]
  ! dot             [ reduce using rule 50 (EXPR -> EXPR divide EXPR .) ]
  ! plus            [ shift and go to state 64 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 59 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 83

    (53) EXPR -> EXPR equals EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    lt              reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    le              reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    equals          reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    comma           reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    in              reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    rparen          reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    semi            reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    then            reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    of              reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    loop            reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    rbrace          reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    else            reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    pool            reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    fi              reduce using rule 53 (EXPR -> EXPR equals EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59

  ! at              [ reduce using rule 53 (EXPR -> EXPR equals EXPR .) ]
  ! dot             [ reduce using rule 53 (EXPR -> EXPR equals EXPR .) ]
  ! plus            [ reduce using rule 53 (EXPR -> EXPR equals EXPR .) ]
  ! minus           [ reduce using rule 53 (EXPR -> EXPR equals EXPR .) ]
  ! times           [ reduce using rule 53 (EXPR -> EXPR equals EXPR .) ]
  ! divide          [ reduce using rule 53 (EXPR -> EXPR equals EXPR .) ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 84

    (49) EXPR -> EXPR times EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    plus            reduce using rule 49 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 49 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 49 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 49 (EXPR -> EXPR times EXPR .)
    lt              reduce using rule 49 (EXPR -> EXPR times EXPR .)
    le              reduce using rule 49 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 49 (EXPR -> EXPR times EXPR .)
    comma           reduce using rule 49 (EXPR -> EXPR times EXPR .)
    in              reduce using rule 49 (EXPR -> EXPR times EXPR .)
    rparen          reduce using rule 49 (EXPR -> EXPR times EXPR .)
    semi            reduce using rule 49 (EXPR -> EXPR times EXPR .)
    then            reduce using rule 49 (EXPR -> EXPR times EXPR .)
    of              reduce using rule 49 (EXPR -> EXPR times EXPR .)
    loop            reduce using rule 49 (EXPR -> EXPR times EXPR .)
    rbrace          reduce using rule 49 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 49 (EXPR -> EXPR times EXPR .)
    pool            reduce using rule 49 (EXPR -> EXPR times EXPR .)
    fi              reduce using rule 49 (EXPR -> EXPR times EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66

  ! at              [ reduce using rule 49 (EXPR -> EXPR times EXPR .) ]
  ! dot             [ reduce using rule 49 (EXPR -> EXPR times EXPR .) ]
  ! plus            [ shift and go to state 64 ]
  ! minus           [ shift and go to state 65 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 59 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 85

    (51) EXPR -> EXPR lt EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    lt              reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    le              reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    equals          reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    comma           reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    in              reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    rparen          reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    semi            reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    then            reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    of              reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    loop            reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    rbrace          reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    else            reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    pool            reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    fi              reduce using rule 51 (EXPR -> EXPR lt EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59

  ! at              [ reduce using rule 51 (EXPR -> EXPR lt EXPR .) ]
  ! dot             [ reduce using rule 51 (EXPR -> EXPR lt EXPR .) ]
  ! plus            [ reduce using rule 51 (EXPR -> EXPR lt EXPR .) ]
  ! minus           [ reduce using rule 51 (EXPR -> EXPR lt EXPR .) ]
  ! times           [ reduce using rule 51 (EXPR -> EXPR lt EXPR .) ]
  ! divide          [ reduce using rule 51 (EXPR -> EXPR lt EXPR .) ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 86

    (21) EXPR -> EXPR at type . dot identifier lparen rparen
    (23) EXPR -> EXPR at type . dot identifier lparen EXPRLISTCOMMA rparen

    dot             shift and go to state 102


state 87

    (47) EXPR -> EXPR plus EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    plus            reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    lt              reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    le              reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    comma           reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    in              reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    rparen          reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    semi            reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    then            reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    of              reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    loop            reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    rbrace          reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    pool            reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    fi              reduce using rule 47 (EXPR -> EXPR plus EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 59

  ! at              [ reduce using rule 47 (EXPR -> EXPR plus EXPR .) ]
  ! dot             [ reduce using rule 47 (EXPR -> EXPR plus EXPR .) ]
  ! times           [ reduce using rule 47 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 47 (EXPR -> EXPR plus EXPR .) ]
  ! plus            [ shift and go to state 64 ]
  ! minus           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 88

    (48) EXPR -> EXPR minus EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    plus            reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    lt              reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    le              reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    comma           reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    in              reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    rparen          reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    semi            reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    then            reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    of              reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    loop            reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    rbrace          reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    pool            reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    fi              reduce using rule 48 (EXPR -> EXPR minus EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 59

  ! at              [ reduce using rule 48 (EXPR -> EXPR minus EXPR .) ]
  ! dot             [ reduce using rule 48 (EXPR -> EXPR minus EXPR .) ]
  ! times           [ reduce using rule 48 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 48 (EXPR -> EXPR minus EXPR .) ]
  ! plus            [ shift and go to state 64 ]
  ! minus           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 58 ]
  ! equals          [ shift and go to state 60 ]


state 89

    (22) EXPR -> EXPR dot identifier . lparen rparen
    (24) EXPR -> EXPR dot identifier . lparen EXPRLISTCOMMA rparen

    lparen          shift and go to state 103


state 90

    (25) EXPR -> let identifier colon . type LETHELPER in EXPR
    (26) EXPR -> let identifier colon . type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> let identifier colon . type in EXPR
    (28) EXPR -> let identifier colon . type larrow EXPR in EXPR

    type            shift and go to state 104


state 91

    (33) EXPR -> lparen EXPR rparen .

    at              reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    dot             reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    plus            reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    minus           reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    times           reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    divide          reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    lt              reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    le              reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    equals          reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    comma           reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    in              reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    rparen          reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    semi            reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    then            reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    of              reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    loop            reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    rbrace          reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    else            reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    pool            reduce using rule 33 (EXPR -> lparen EXPR rparen .)
    fi              reduce using rule 33 (EXPR -> lparen EXPR rparen .)


state 92

    (17) EXPR -> case EXPR of . CASEHELPER esac
    (18) CASEHELPER -> . CASEHELPER CASELIT
    (19) CASEHELPER -> . CASELIT
    (20) CASELIT -> . identifier colon type rarrow EXPR semi

    identifier      shift and go to state 107

    CASELIT                        shift and go to state 105
    CASEHELPER                     shift and go to state 106

state 93

    (34) EXPR -> lbrace EXPRLISTSEMI semi . rbrace
    (42) EXPRLISTSEMI -> EXPRLISTSEMI semi . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    rbrace          shift and go to state 108
    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 109

state 94

    (39) EXPR -> while EXPR loop . EXPR pool
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 110

state 95

    (37) EXPR -> identifier larrow EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    in              reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    rparen          reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    semi            reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    then            reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    of              reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    loop            reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    rbrace          reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    else            reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    pool            reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    fi              reduce using rule 37 (EXPR -> identifier larrow EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

  ! at              [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! dot             [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! plus            [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! minus           [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! times           [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! divide          [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! lt              [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! le              [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]
  ! equals          [ reduce using rule 37 (EXPR -> identifier larrow EXPR .) ]


state 96

    (36) EXPR -> identifier lparen EXPRLISTCOMMA . rparen
    (40) EXPRLISTCOMMA -> EXPRLISTCOMMA . comma EXPR

    rparen          shift and go to state 111
    comma           shift and go to state 112


state 97

    (41) EXPRLISTCOMMA -> EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    rparen          reduce using rule 41 (EXPRLISTCOMMA -> EXPR .)
    comma           reduce using rule 41 (EXPRLISTCOMMA -> EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 98

    (35) EXPR -> identifier lparen rparen .

    at              reduce using rule 35 (EXPR -> identifier lparen rparen .)
    dot             reduce using rule 35 (EXPR -> identifier lparen rparen .)
    plus            reduce using rule 35 (EXPR -> identifier lparen rparen .)
    minus           reduce using rule 35 (EXPR -> identifier lparen rparen .)
    times           reduce using rule 35 (EXPR -> identifier lparen rparen .)
    divide          reduce using rule 35 (EXPR -> identifier lparen rparen .)
    lt              reduce using rule 35 (EXPR -> identifier lparen rparen .)
    le              reduce using rule 35 (EXPR -> identifier lparen rparen .)
    equals          reduce using rule 35 (EXPR -> identifier lparen rparen .)
    comma           reduce using rule 35 (EXPR -> identifier lparen rparen .)
    in              reduce using rule 35 (EXPR -> identifier lparen rparen .)
    rparen          reduce using rule 35 (EXPR -> identifier lparen rparen .)
    semi            reduce using rule 35 (EXPR -> identifier lparen rparen .)
    then            reduce using rule 35 (EXPR -> identifier lparen rparen .)
    of              reduce using rule 35 (EXPR -> identifier lparen rparen .)
    loop            reduce using rule 35 (EXPR -> identifier lparen rparen .)
    rbrace          reduce using rule 35 (EXPR -> identifier lparen rparen .)
    else            reduce using rule 35 (EXPR -> identifier lparen rparen .)
    pool            reduce using rule 35 (EXPR -> identifier lparen rparen .)
    fi              reduce using rule 35 (EXPR -> identifier lparen rparen .)


state 99

    (11) FEATURELIT -> identifier lparen rparen colon type lbrace EXPR . rbrace
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 113
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 100

    (10) FEATURELIT -> identifier lparen FORMAL rparen colon type lbrace . EXPR rbrace
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 114

state 101

    (38) EXPR -> if EXPR then EXPR . else EXPR fi
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    else            shift and go to state 115
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 102

    (21) EXPR -> EXPR at type dot . identifier lparen rparen
    (23) EXPR -> EXPR at type dot . identifier lparen EXPRLISTCOMMA rparen

    identifier      shift and go to state 116


state 103

    (22) EXPR -> EXPR dot identifier lparen . rparen
    (24) EXPR -> EXPR dot identifier lparen . EXPRLISTCOMMA rparen
    (40) EXPRLISTCOMMA -> . EXPRLISTCOMMA comma EXPR
    (41) EXPRLISTCOMMA -> . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    rparen          shift and go to state 118
    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 97
    EXPRLISTCOMMA                  shift and go to state 117

state 104

    (25) EXPR -> let identifier colon type . LETHELPER in EXPR
    (26) EXPR -> let identifier colon type . larrow EXPR LETHELPER in EXPR
    (27) EXPR -> let identifier colon type . in EXPR
    (28) EXPR -> let identifier colon type . larrow EXPR in EXPR
    (29) LETHELPER -> . comma LETHELPERLIT LETHELPER
    (30) LETHELPER -> . comma LETHELPERLIT

    larrow          shift and go to state 120
    in              shift and go to state 122
    comma           shift and go to state 119

    LETHELPER                      shift and go to state 121

state 105

    (19) CASEHELPER -> CASELIT .

    esac            reduce using rule 19 (CASEHELPER -> CASELIT .)
    identifier      reduce using rule 19 (CASEHELPER -> CASELIT .)


state 106

    (17) EXPR -> case EXPR of CASEHELPER . esac
    (18) CASEHELPER -> CASEHELPER . CASELIT
    (20) CASELIT -> . identifier colon type rarrow EXPR semi

    esac            shift and go to state 124
    identifier      shift and go to state 107

    CASELIT                        shift and go to state 123

state 107

    (20) CASELIT -> identifier . colon type rarrow EXPR semi

    colon           shift and go to state 125


state 108

    (34) EXPR -> lbrace EXPRLISTSEMI semi rbrace .

    at              reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    dot             reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    plus            reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    minus           reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    times           reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    divide          reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    lt              reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    le              reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    equals          reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    comma           reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    in              reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    rparen          reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    semi            reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    then            reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    of              reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    loop            reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    rbrace          reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    else            reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    pool            reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)
    fi              reduce using rule 34 (EXPR -> lbrace EXPRLISTSEMI semi rbrace .)


state 109

    (42) EXPRLISTSEMI -> EXPRLISTSEMI semi EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 42 (EXPRLISTSEMI -> EXPRLISTSEMI semi EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 110

    (39) EXPR -> while EXPR loop EXPR . pool
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    pool            shift and go to state 126
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 111

    (36) EXPR -> identifier lparen EXPRLISTCOMMA rparen .

    at              reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    dot             reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    plus            reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    minus           reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    times           reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    divide          reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    lt              reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    le              reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    equals          reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    comma           reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    in              reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    rparen          reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    semi            reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    then            reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    of              reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    loop            reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    rbrace          reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    else            reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    pool            reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)
    fi              reduce using rule 36 (EXPR -> identifier lparen EXPRLISTCOMMA rparen .)


state 112

    (40) EXPRLISTCOMMA -> EXPRLISTCOMMA comma . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 127

state 113

    (11) FEATURELIT -> identifier lparen rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 11 (FEATURELIT -> identifier lparen rparen colon type lbrace EXPR rbrace .)


state 114

    (10) FEATURELIT -> identifier lparen FORMAL rparen colon type lbrace EXPR . rbrace
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 128
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 115

    (38) EXPR -> if EXPR then EXPR else . EXPR fi
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 129

state 116

    (21) EXPR -> EXPR at type dot identifier . lparen rparen
    (23) EXPR -> EXPR at type dot identifier . lparen EXPRLISTCOMMA rparen

    lparen          shift and go to state 130


state 117

    (24) EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA . rparen
    (40) EXPRLISTCOMMA -> EXPRLISTCOMMA . comma EXPR

    rparen          shift and go to state 131
    comma           shift and go to state 112


state 118

    (22) EXPR -> EXPR dot identifier lparen rparen .

    at              reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    dot             reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    plus            reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    minus           reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    times           reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    divide          reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    lt              reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    le              reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    equals          reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    comma           reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    in              reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    rparen          reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    semi            reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    then            reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    of              reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    loop            reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    rbrace          reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    else            reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    pool            reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)
    fi              reduce using rule 22 (EXPR -> EXPR dot identifier lparen rparen .)


state 119

    (29) LETHELPER -> comma . LETHELPERLIT LETHELPER
    (30) LETHELPER -> comma . LETHELPERLIT
    (31) LETHELPERLIT -> . identifier colon type
    (32) LETHELPERLIT -> . identifier colon type larrow EXPR

    identifier      shift and go to state 133

    LETHELPERLIT                   shift and go to state 132

state 120

    (26) EXPR -> let identifier colon type larrow . EXPR LETHELPER in EXPR
    (28) EXPR -> let identifier colon type larrow . EXPR in EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 134

state 121

    (25) EXPR -> let identifier colon type LETHELPER . in EXPR

    in              shift and go to state 135


state 122

    (27) EXPR -> let identifier colon type in . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 136

state 123

    (18) CASEHELPER -> CASEHELPER CASELIT .

    esac            reduce using rule 18 (CASEHELPER -> CASEHELPER CASELIT .)
    identifier      reduce using rule 18 (CASEHELPER -> CASEHELPER CASELIT .)


state 124

    (17) EXPR -> case EXPR of CASEHELPER esac .

    at              reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    dot             reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    plus            reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    minus           reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    times           reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    divide          reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    lt              reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    le              reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    equals          reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    comma           reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    in              reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    rparen          reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    semi            reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    then            reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    of              reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    loop            reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    rbrace          reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    else            reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    pool            reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)
    fi              reduce using rule 17 (EXPR -> case EXPR of CASEHELPER esac .)


state 125

    (20) CASELIT -> identifier colon . type rarrow EXPR semi

    type            shift and go to state 137


state 126

    (39) EXPR -> while EXPR loop EXPR pool .

    at              reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    dot             reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    plus            reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    minus           reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    times           reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    divide          reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    lt              reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    le              reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    equals          reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    comma           reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    in              reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    rparen          reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    semi            reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    then            reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    of              reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    loop            reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    rbrace          reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    else            reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    pool            reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)
    fi              reduce using rule 39 (EXPR -> while EXPR loop EXPR pool .)


state 127

    (40) EXPRLISTCOMMA -> EXPRLISTCOMMA comma EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    rparen          reduce using rule 40 (EXPRLISTCOMMA -> EXPRLISTCOMMA comma EXPR .)
    comma           reduce using rule 40 (EXPRLISTCOMMA -> EXPRLISTCOMMA comma EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 128

    (10) FEATURELIT -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 10 (FEATURELIT -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .)


state 129

    (38) EXPR -> if EXPR then EXPR else EXPR . fi
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    fi              shift and go to state 138
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 130

    (21) EXPR -> EXPR at type dot identifier lparen . rparen
    (23) EXPR -> EXPR at type dot identifier lparen . EXPRLISTCOMMA rparen
    (40) EXPRLISTCOMMA -> . EXPRLISTCOMMA comma EXPR
    (41) EXPRLISTCOMMA -> . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    rparen          shift and go to state 140
    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 97
    EXPRLISTCOMMA                  shift and go to state 139

state 131

    (24) EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .

    at              reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    dot             reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    plus            reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    minus           reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    times           reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    divide          reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    lt              reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    le              reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    equals          reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    comma           reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    in              reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    rparen          reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    semi            reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    then            reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    of              reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    loop            reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    rbrace          reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    else            reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    pool            reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)
    fi              reduce using rule 24 (EXPR -> EXPR dot identifier lparen EXPRLISTCOMMA rparen .)


state 132

    (29) LETHELPER -> comma LETHELPERLIT . LETHELPER
    (30) LETHELPER -> comma LETHELPERLIT .
    (29) LETHELPER -> . comma LETHELPERLIT LETHELPER
    (30) LETHELPER -> . comma LETHELPERLIT

    in              reduce using rule 30 (LETHELPER -> comma LETHELPERLIT .)
    comma           shift and go to state 119

    LETHELPER                      shift and go to state 141

state 133

    (31) LETHELPERLIT -> identifier . colon type
    (32) LETHELPERLIT -> identifier . colon type larrow EXPR

    colon           shift and go to state 142


state 134

    (26) EXPR -> let identifier colon type larrow EXPR . LETHELPER in EXPR
    (28) EXPR -> let identifier colon type larrow EXPR . in EXPR
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR
    (29) LETHELPER -> . comma LETHELPERLIT LETHELPER
    (30) LETHELPER -> . comma LETHELPERLIT

    in              shift and go to state 144
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60
    comma           shift and go to state 119

    LETHELPER                      shift and go to state 143

state 135

    (25) EXPR -> let identifier colon type LETHELPER in . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 145

state 136

    (27) EXPR -> let identifier colon type in EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    comma           reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    in              reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    rparen          reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    semi            reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    then            reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    of              reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    loop            reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    rbrace          reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    else            reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    pool            reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    fi              reduce using rule 27 (EXPR -> let identifier colon type in EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

  ! at              [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! dot             [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! plus            [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! minus           [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! times           [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! divide          [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! lt              [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! le              [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]
  ! equals          [ reduce using rule 27 (EXPR -> let identifier colon type in EXPR .) ]


state 137

    (20) CASELIT -> identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 146


state 138

    (38) EXPR -> if EXPR then EXPR else EXPR fi .

    at              reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    dot             reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    plus            reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    minus           reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    times           reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    divide          reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    lt              reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    le              reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    equals          reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    comma           reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    in              reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rparen          reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    semi            reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    then            reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    of              reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    loop            reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rbrace          reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    else            reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    pool            reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)
    fi              reduce using rule 38 (EXPR -> if EXPR then EXPR else EXPR fi .)


state 139

    (23) EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA . rparen
    (40) EXPRLISTCOMMA -> EXPRLISTCOMMA . comma EXPR

    rparen          shift and go to state 147
    comma           shift and go to state 112


state 140

    (21) EXPR -> EXPR at type dot identifier lparen rparen .

    at              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    dot             reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    plus            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    minus           reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    times           reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    divide          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    lt              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    le              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    equals          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    comma           reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    in              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rparen          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    semi            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    then            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    of              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    loop            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rbrace          reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    else            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    pool            reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)
    fi              reduce using rule 21 (EXPR -> EXPR at type dot identifier lparen rparen .)


state 141

    (29) LETHELPER -> comma LETHELPERLIT LETHELPER .

    in              reduce using rule 29 (LETHELPER -> comma LETHELPERLIT LETHELPER .)


state 142

    (31) LETHELPERLIT -> identifier colon . type
    (32) LETHELPERLIT -> identifier colon . type larrow EXPR

    type            shift and go to state 148


state 143

    (26) EXPR -> let identifier colon type larrow EXPR LETHELPER . in EXPR

    in              shift and go to state 149


state 144

    (28) EXPR -> let identifier colon type larrow EXPR in . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 150

state 145

    (25) EXPR -> let identifier colon type LETHELPER in EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    comma           reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    in              reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rparen          reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    semi            reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    then            reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    of              reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    loop            reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rbrace          reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    else            reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    pool            reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    fi              reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

  ! at              [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 25 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]


state 146

    (20) CASELIT -> identifier colon type rarrow . EXPR semi
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 151

state 147

    (23) EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .

    at              reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    dot             reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    plus            reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    minus           reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    times           reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    divide          reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    lt              reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    le              reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    equals          reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    comma           reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    in              reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    rparen          reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    semi            reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    then            reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    of              reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    loop            reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    rbrace          reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    else            reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    pool            reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)
    fi              reduce using rule 23 (EXPR -> EXPR at type dot identifier lparen EXPRLISTCOMMA rparen .)


state 148

    (31) LETHELPERLIT -> identifier colon type .
    (32) LETHELPERLIT -> identifier colon type . larrow EXPR

    comma           reduce using rule 31 (LETHELPERLIT -> identifier colon type .)
    in              reduce using rule 31 (LETHELPERLIT -> identifier colon type .)
    larrow          shift and go to state 152


state 149

    (26) EXPR -> let identifier colon type larrow EXPR LETHELPER in . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 153

state 150

    (28) EXPR -> let identifier colon type larrow EXPR in EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    comma           reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    in              reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    rparen          reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    semi            reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    then            reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    of              reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    loop            reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    rbrace          reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    else            reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    pool            reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    fi              reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

  ! at              [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! dot             [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! plus            [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! minus           [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! times           [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! divide          [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! lt              [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! le              [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! equals          [ reduce using rule 28 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]


state 151

    (20) CASELIT -> identifier colon type rarrow EXPR . semi
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 154
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60


state 152

    (32) LETHELPERLIT -> identifier colon type larrow . EXPR
    (17) EXPR -> . case EXPR of CASEHELPER esac
    (21) EXPR -> . EXPR at type dot identifier lparen rparen
    (22) EXPR -> . EXPR dot identifier lparen rparen
    (23) EXPR -> . EXPR at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> . EXPR dot identifier lparen EXPRLISTCOMMA rparen
    (25) EXPR -> . let identifier colon type LETHELPER in EXPR
    (26) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (27) EXPR -> . let identifier colon type in EXPR
    (28) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (33) EXPR -> . lparen EXPR rparen
    (34) EXPR -> . lbrace EXPRLISTSEMI semi rbrace
    (35) EXPR -> . identifier lparen rparen
    (36) EXPR -> . identifier lparen EXPRLISTCOMMA rparen
    (37) EXPR -> . identifier larrow EXPR
    (38) EXPR -> . if EXPR then EXPR else EXPR fi
    (39) EXPR -> . while EXPR loop EXPR pool
    (44) EXPR -> . isvoid EXPR
    (45) EXPR -> . tilde EXPR
    (46) EXPR -> . not EXPR
    (47) EXPR -> . EXPR plus EXPR
    (48) EXPR -> . EXPR minus EXPR
    (49) EXPR -> . EXPR times EXPR
    (50) EXPR -> . EXPR divide EXPR
    (51) EXPR -> . EXPR lt EXPR
    (52) EXPR -> . EXPR le EXPR
    (53) EXPR -> . EXPR equals EXPR
    (54) EXPR -> . identifier
    (55) EXPR -> . integer
    (56) EXPR -> . string
    (57) EXPR -> . true
    (58) EXPR -> . false
    (59) EXPR -> . new type

    case            shift and go to state 48
    let             shift and go to state 43
    lparen          shift and go to state 44
    lbrace          shift and go to state 49
    identifier      shift and go to state 51
    if              shift and go to state 38
    while           shift and go to state 50
    isvoid          shift and go to state 41
    tilde           shift and go to state 37
    not             shift and go to state 46
    integer         shift and go to state 39
    string          shift and go to state 42
    true            shift and go to state 47
    false           shift and go to state 36
    new             shift and go to state 45

    EXPR                           shift and go to state 155

state 153

    (26) EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    comma           reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    in              reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rparen          reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    semi            reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    then            reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    of              reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    loop            reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rbrace          reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    else            reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    pool            reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    fi              reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

  ! at              [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 26 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]


state 154

    (20) CASELIT -> identifier colon type rarrow EXPR semi .

    esac            reduce using rule 20 (CASELIT -> identifier colon type rarrow EXPR semi .)
    identifier      reduce using rule 20 (CASELIT -> identifier colon type rarrow EXPR semi .)


state 155

    (32) LETHELPERLIT -> identifier colon type larrow EXPR .
    (21) EXPR -> EXPR . at type dot identifier lparen rparen
    (22) EXPR -> EXPR . dot identifier lparen rparen
    (23) EXPR -> EXPR . at type dot identifier lparen EXPRLISTCOMMA rparen
    (24) EXPR -> EXPR . dot identifier lparen EXPRLISTCOMMA rparen
    (47) EXPR -> EXPR . plus EXPR
    (48) EXPR -> EXPR . minus EXPR
    (49) EXPR -> EXPR . times EXPR
    (50) EXPR -> EXPR . divide EXPR
    (51) EXPR -> EXPR . lt EXPR
    (52) EXPR -> EXPR . le EXPR
    (53) EXPR -> EXPR . equals EXPR

    comma           reduce using rule 32 (LETHELPERLIT -> identifier colon type larrow EXPR .)
    in              reduce using rule 32 (LETHELPERLIT -> identifier colon type larrow EXPR .)
    at              shift and go to state 63
    dot             shift and go to state 66
    plus            shift and go to state 64
    minus           shift and go to state 65
    times           shift and go to state 61
    divide          shift and go to state 59
    lt              shift and go to state 62
    le              shift and go to state 58
    equals          shift and go to state 60

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for at in state 136 resolved as shift
WARNING: shift/reduce conflict for dot in state 136 resolved as shift
WARNING: shift/reduce conflict for plus in state 136 resolved as shift
WARNING: shift/reduce conflict for minus in state 136 resolved as shift
WARNING: shift/reduce conflict for times in state 136 resolved as shift
WARNING: shift/reduce conflict for divide in state 136 resolved as shift
WARNING: shift/reduce conflict for lt in state 136 resolved as shift
WARNING: shift/reduce conflict for le in state 136 resolved as shift
WARNING: shift/reduce conflict for equals in state 136 resolved as shift
WARNING: shift/reduce conflict for at in state 145 resolved as shift
WARNING: shift/reduce conflict for dot in state 145 resolved as shift
WARNING: shift/reduce conflict for plus in state 145 resolved as shift
WARNING: shift/reduce conflict for minus in state 145 resolved as shift
WARNING: shift/reduce conflict for times in state 145 resolved as shift
WARNING: shift/reduce conflict for divide in state 145 resolved as shift
WARNING: shift/reduce conflict for lt in state 145 resolved as shift
WARNING: shift/reduce conflict for le in state 145 resolved as shift
WARNING: shift/reduce conflict for equals in state 145 resolved as shift
WARNING: shift/reduce conflict for at in state 150 resolved as shift
WARNING: shift/reduce conflict for dot in state 150 resolved as shift
WARNING: shift/reduce conflict for plus in state 150 resolved as shift
WARNING: shift/reduce conflict for minus in state 150 resolved as shift
WARNING: shift/reduce conflict for times in state 150 resolved as shift
WARNING: shift/reduce conflict for divide in state 150 resolved as shift
WARNING: shift/reduce conflict for lt in state 150 resolved as shift
WARNING: shift/reduce conflict for le in state 150 resolved as shift
WARNING: shift/reduce conflict for equals in state 150 resolved as shift
WARNING: shift/reduce conflict for at in state 153 resolved as shift
WARNING: shift/reduce conflict for dot in state 153 resolved as shift
WARNING: shift/reduce conflict for plus in state 153 resolved as shift
WARNING: shift/reduce conflict for minus in state 153 resolved as shift
WARNING: shift/reduce conflict for times in state 153 resolved as shift
WARNING: shift/reduce conflict for divide in state 153 resolved as shift
WARNING: shift/reduce conflict for lt in state 153 resolved as shift
WARNING: shift/reduce conflict for le in state 153 resolved as shift
WARNING: shift/reduce conflict for equals in state 153 resolved as shift
