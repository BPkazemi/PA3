Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> CLASSDEF semi
Rule 2     PROGRAM -> PROGRAM CLASSDEF semi
Rule 3     CLASSDEF -> class type lbrace rbrace
Rule 4     CLASSDEF -> class type lbrace FEATURE semi rbrace
Rule 5     CLASSDEF -> class type inherits type lbrace rbrace
Rule 6     CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace
Rule 7     FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
Rule 8     FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace
Rule 9     FEATURE -> identifier colon type
Rule 10    FEATURE -> identifier colon type larrow EXPR
Rule 11    FEATURE -> FEATURELIST FEATURE
Rule 12    FEATURELIST -> FEATURELIST FEATURE semi
Rule 13    FEATURELIST -> <empty>
Rule 14    FORMAL -> identifier colon type
Rule 15    FORMAL -> FORMAL comma identifier colon type
Rule 16    EXPR -> case EXPR of CASEHELPER esac
Rule 17    CASEHELPER -> identifier colon type rarrow EXPR semi
Rule 18    CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi
Rule 19    EXPR -> EXPR at type dot identifier lparen EXPR rparen
Rule 20    EXPR -> EXPR dot identifier lparen EXPR rparen
Rule 21    EXPR -> let identifier colon type LETHELPER in EXPR
Rule 22    EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR
Rule 23    LETHELPER -> comma identifier colon type LETHELPER
Rule 24    LETHELPER -> comma identifier colon type larrow EXPR LETHELPER
Rule 25    LETHELPER -> <empty>
Rule 26    EXPR -> lparen EXPR rparen
Rule 27    EXPR -> lbrace EXPR semi rbrace
Rule 28    EXPR -> identifier larrow EXPR
Rule 29    EXPR -> identifier lparen EXPR rparen
Rule 30    EXPR -> EXPR at type dot identifier lparen rparen
Rule 31    EXPR -> EXPR dot identifier lparen rparen
Rule 32    EXPR -> if EXPR then EXPR else EXPR fi
Rule 33    EXPR -> while EXPR loop EXPR pool
Rule 34    EXPR -> EXPR semi EXPR
Rule 35    EXPR -> EXPR comma EXPR
Rule 36    EXPR -> isvoid EXPR
Rule 37    EXPR -> tilde EXPR
Rule 38    EXPR -> not EXPR
Rule 39    EXPR -> EXPR plus EXPR
Rule 40    EXPR -> EXPR minus EXPR
Rule 41    EXPR -> EXPR times EXPR
Rule 42    EXPR -> EXPR divide EXPR
Rule 43    EXPR -> EXPR lt EXPR
Rule 44    EXPR -> EXPR le EXPR
Rule 45    EXPR -> EXPR equals EXPR
Rule 46    EXPR -> identifier
Rule 47    EXPR -> integer
Rule 48    EXPR -> string
Rule 49    EXPR -> true
Rule 50    EXPR -> false
Rule 51    EXPR -> identifier lparen rparen
Rule 52    EXPR -> new type

Terminals, with rules where they appear

at                   : 19 30
case                 : 16
class                : 3 4 5 6
colon                : 7 8 9 10 14 15 17 18 21 22 23 24
comma                : 15 23 24 35
divide               : 42
dot                  : 19 20 30 31
else                 : 32
equals               : 45
error                : 
esac                 : 16
false                : 50
fi                   : 32
identifier           : 7 8 9 10 14 15 17 18 19 20 21 22 23 24 28 29 30 31 46 51
if                   : 32
in                   : 21 22
inherits             : 5 6
integer              : 47
isvoid               : 36
larrow               : 10 22 24 28
lbrace               : 3 4 5 6 7 8 27
le                   : 44
let                  : 21 22
loop                 : 33
lparen               : 7 8 19 20 26 29 30 31 51
lt                   : 43
minus                : 40
new                  : 52
not                  : 38
of                   : 16
plus                 : 39
pool                 : 33
rarrow               : 17 18
rbrace               : 3 4 5 6 7 8 27
rparen               : 7 8 19 20 26 29 30 31 51
semi                 : 1 2 4 6 12 17 18 27 34
string               : 48
then                 : 32
tilde                : 37
times                : 41
true                 : 49
type                 : 3 4 5 5 6 6 7 8 9 10 14 15 17 18 19 21 22 23 24 30 52
while                : 33

Nonterminals, with rules where they appear

CASEHELPER           : 16 18
CLASSDEF             : 1 2
EXPR                 : 7 8 10 16 17 18 19 19 20 20 21 22 22 24 26 27 28 29 30 31 32 32 32 33 33 34 34 35 35 36 37 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45
FEATURE              : 4 6 11 12
FEATURELIST          : 11 12
FORMAL               : 7 15
LETHELPER            : 21 22 23 24
PROGRAM              : 2 0

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . CLASSDEF semi
    (2) PROGRAM -> . PROGRAM CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 3

    PROGRAM                        shift and go to state 2
    CLASSDEF                       shift and go to state 1

state 1

    (1) PROGRAM -> CLASSDEF . semi

    semi            shift and go to state 4


state 2

    (0) S' -> PROGRAM .
    (2) PROGRAM -> PROGRAM . CLASSDEF semi
    (3) CLASSDEF -> . class type lbrace rbrace
    (4) CLASSDEF -> . class type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> . class type inherits type lbrace rbrace
    (6) CLASSDEF -> . class type inherits type lbrace FEATURE semi rbrace

    class           shift and go to state 3

    CLASSDEF                       shift and go to state 5

state 3

    (3) CLASSDEF -> class . type lbrace rbrace
    (4) CLASSDEF -> class . type lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class . type inherits type lbrace rbrace
    (6) CLASSDEF -> class . type inherits type lbrace FEATURE semi rbrace

    type            shift and go to state 6


state 4

    (1) PROGRAM -> CLASSDEF semi .

    class           reduce using rule 1 (PROGRAM -> CLASSDEF semi .)
    $end            reduce using rule 1 (PROGRAM -> CLASSDEF semi .)


state 5

    (2) PROGRAM -> PROGRAM CLASSDEF . semi

    semi            shift and go to state 7


state 6

    (3) CLASSDEF -> class type . lbrace rbrace
    (4) CLASSDEF -> class type . lbrace FEATURE semi rbrace
    (5) CLASSDEF -> class type . inherits type lbrace rbrace
    (6) CLASSDEF -> class type . inherits type lbrace FEATURE semi rbrace

    lbrace          shift and go to state 9
    inherits        shift and go to state 8


state 7

    (2) PROGRAM -> PROGRAM CLASSDEF semi .

    class           reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)
    $end            reduce using rule 2 (PROGRAM -> PROGRAM CLASSDEF semi .)


state 8

    (5) CLASSDEF -> class type inherits . type lbrace rbrace
    (6) CLASSDEF -> class type inherits . type lbrace FEATURE semi rbrace

    type            shift and go to state 10


state 9

    (3) CLASSDEF -> class type lbrace . rbrace
    (4) CLASSDEF -> class type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST FEATURE
    (12) FEATURELIST -> . FEATURELIST FEATURE semi
    (13) FEATURELIST -> .

  ! shift/reduce conflict for identifier resolved as shift
    rbrace          shift and go to state 11
    identifier      shift and go to state 14

  ! identifier      [ reduce using rule 13 (FEATURELIST -> .) ]

    FEATURELIST                    shift and go to state 13
    FEATURE                        shift and go to state 12

state 10

    (5) CLASSDEF -> class type inherits type . lbrace rbrace
    (6) CLASSDEF -> class type inherits type . lbrace FEATURE semi rbrace

    lbrace          shift and go to state 15


state 11

    (3) CLASSDEF -> class type lbrace rbrace .

    semi            reduce using rule 3 (CLASSDEF -> class type lbrace rbrace .)


state 12

    (4) CLASSDEF -> class type lbrace FEATURE . semi rbrace

    semi            shift and go to state 16


state 13

    (11) FEATURE -> FEATURELIST . FEATURE
    (12) FEATURELIST -> FEATURELIST . FEATURE semi
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST FEATURE
    (12) FEATURELIST -> . FEATURELIST FEATURE semi
    (13) FEATURELIST -> .

  ! shift/reduce conflict for identifier resolved as shift
    identifier      shift and go to state 14

  ! identifier      [ reduce using rule 13 (FEATURELIST -> .) ]

    FEATURELIST                    shift and go to state 13
    FEATURE                        shift and go to state 17

state 14

    (7) FEATURE -> identifier . lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier . lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> identifier . colon type
    (10) FEATURE -> identifier . colon type larrow EXPR

    lparen          shift and go to state 19
    colon           shift and go to state 18


state 15

    (5) CLASSDEF -> class type inherits type lbrace . rbrace
    (6) CLASSDEF -> class type inherits type lbrace . FEATURE semi rbrace
    (7) FEATURE -> . identifier lparen FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR
    (11) FEATURE -> . FEATURELIST FEATURE
    (12) FEATURELIST -> . FEATURELIST FEATURE semi
    (13) FEATURELIST -> .

  ! shift/reduce conflict for identifier resolved as shift
    rbrace          shift and go to state 20
    identifier      shift and go to state 14

  ! identifier      [ reduce using rule 13 (FEATURELIST -> .) ]

    FEATURELIST                    shift and go to state 13
    FEATURE                        shift and go to state 21

state 16

    (4) CLASSDEF -> class type lbrace FEATURE semi . rbrace

    rbrace          shift and go to state 22


state 17

    (11) FEATURE -> FEATURELIST FEATURE .
    (12) FEATURELIST -> FEATURELIST FEATURE . semi

  ! shift/reduce conflict for semi resolved as shift
    semi            shift and go to state 23

  ! semi            [ reduce using rule 11 (FEATURE -> FEATURELIST FEATURE .) ]


state 18

    (9) FEATURE -> identifier colon . type
    (10) FEATURE -> identifier colon . type larrow EXPR

    type            shift and go to state 24


state 19

    (7) FEATURE -> identifier lparen . FORMAL rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier lparen . rparen colon type lbrace EXPR rbrace
    (14) FORMAL -> . identifier colon type
    (15) FORMAL -> . FORMAL comma identifier colon type

    rparen          shift and go to state 25
    identifier      shift and go to state 26

    FORMAL                         shift and go to state 27

state 20

    (5) CLASSDEF -> class type inherits type lbrace rbrace .

    semi            reduce using rule 5 (CLASSDEF -> class type inherits type lbrace rbrace .)


state 21

    (6) CLASSDEF -> class type inherits type lbrace FEATURE . semi rbrace

    semi            shift and go to state 28


state 22

    (4) CLASSDEF -> class type lbrace FEATURE semi rbrace .

    semi            reduce using rule 4 (CLASSDEF -> class type lbrace FEATURE semi rbrace .)


state 23

    (12) FEATURELIST -> FEATURELIST FEATURE semi .

    identifier      reduce using rule 12 (FEATURELIST -> FEATURELIST FEATURE semi .)


state 24

    (9) FEATURE -> identifier colon type .
    (10) FEATURE -> identifier colon type . larrow EXPR

    semi            reduce using rule 9 (FEATURE -> identifier colon type .)
    larrow          shift and go to state 29


state 25

    (8) FEATURE -> identifier lparen rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 30


state 26

    (14) FORMAL -> identifier . colon type

    colon           shift and go to state 31


state 27

    (7) FEATURE -> identifier lparen FORMAL . rparen colon type lbrace EXPR rbrace
    (15) FORMAL -> FORMAL . comma identifier colon type

    rparen          shift and go to state 32
    comma           shift and go to state 33


state 28

    (6) CLASSDEF -> class type inherits type lbrace FEATURE semi . rbrace

    rbrace          shift and go to state 34


state 29

    (10) FEATURE -> identifier colon type larrow . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 39

state 30

    (8) FEATURE -> identifier lparen rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 51


state 31

    (14) FORMAL -> identifier colon . type

    type            shift and go to state 52


state 32

    (7) FEATURE -> identifier lparen FORMAL rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 53


state 33

    (15) FORMAL -> FORMAL comma . identifier colon type

    identifier      shift and go to state 54


state 34

    (6) CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .

    semi            reduce using rule 6 (CLASSDEF -> class type inherits type lbrace FEATURE semi rbrace .)


state 35

    (50) EXPR -> false .

    rbrace          reduce using rule 50 (EXPR -> false .)
    at              reduce using rule 50 (EXPR -> false .)
    dot             reduce using rule 50 (EXPR -> false .)
    semi            reduce using rule 50 (EXPR -> false .)
    comma           reduce using rule 50 (EXPR -> false .)
    plus            reduce using rule 50 (EXPR -> false .)
    minus           reduce using rule 50 (EXPR -> false .)
    times           reduce using rule 50 (EXPR -> false .)
    divide          reduce using rule 50 (EXPR -> false .)
    lt              reduce using rule 50 (EXPR -> false .)
    le              reduce using rule 50 (EXPR -> false .)
    equals          reduce using rule 50 (EXPR -> false .)
    in              reduce using rule 50 (EXPR -> false .)
    then            reduce using rule 50 (EXPR -> false .)
    rparen          reduce using rule 50 (EXPR -> false .)
    of              reduce using rule 50 (EXPR -> false .)
    loop            reduce using rule 50 (EXPR -> false .)
    else            reduce using rule 50 (EXPR -> false .)
    pool            reduce using rule 50 (EXPR -> false .)
    fi              reduce using rule 50 (EXPR -> false .)


state 36

    (37) EXPR -> tilde . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 55

state 37

    (32) EXPR -> if . EXPR then EXPR else EXPR fi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 56

state 38

    (47) EXPR -> integer .

    rbrace          reduce using rule 47 (EXPR -> integer .)
    at              reduce using rule 47 (EXPR -> integer .)
    dot             reduce using rule 47 (EXPR -> integer .)
    semi            reduce using rule 47 (EXPR -> integer .)
    comma           reduce using rule 47 (EXPR -> integer .)
    plus            reduce using rule 47 (EXPR -> integer .)
    minus           reduce using rule 47 (EXPR -> integer .)
    times           reduce using rule 47 (EXPR -> integer .)
    divide          reduce using rule 47 (EXPR -> integer .)
    lt              reduce using rule 47 (EXPR -> integer .)
    le              reduce using rule 47 (EXPR -> integer .)
    equals          reduce using rule 47 (EXPR -> integer .)
    in              reduce using rule 47 (EXPR -> integer .)
    then            reduce using rule 47 (EXPR -> integer .)
    rparen          reduce using rule 47 (EXPR -> integer .)
    of              reduce using rule 47 (EXPR -> integer .)
    loop            reduce using rule 47 (EXPR -> integer .)
    else            reduce using rule 47 (EXPR -> integer .)
    pool            reduce using rule 47 (EXPR -> integer .)
    fi              reduce using rule 47 (EXPR -> integer .)


state 39

    (10) FEATURE -> identifier colon type larrow EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 10 (FEATURE -> identifier colon type larrow EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! semi            [ shift and go to state 59 ]


state 40

    (36) EXPR -> isvoid . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 68

state 41

    (48) EXPR -> string .

    rbrace          reduce using rule 48 (EXPR -> string .)
    at              reduce using rule 48 (EXPR -> string .)
    dot             reduce using rule 48 (EXPR -> string .)
    semi            reduce using rule 48 (EXPR -> string .)
    comma           reduce using rule 48 (EXPR -> string .)
    plus            reduce using rule 48 (EXPR -> string .)
    minus           reduce using rule 48 (EXPR -> string .)
    times           reduce using rule 48 (EXPR -> string .)
    divide          reduce using rule 48 (EXPR -> string .)
    lt              reduce using rule 48 (EXPR -> string .)
    le              reduce using rule 48 (EXPR -> string .)
    equals          reduce using rule 48 (EXPR -> string .)
    in              reduce using rule 48 (EXPR -> string .)
    then            reduce using rule 48 (EXPR -> string .)
    rparen          reduce using rule 48 (EXPR -> string .)
    of              reduce using rule 48 (EXPR -> string .)
    loop            reduce using rule 48 (EXPR -> string .)
    else            reduce using rule 48 (EXPR -> string .)
    pool            reduce using rule 48 (EXPR -> string .)
    fi              reduce using rule 48 (EXPR -> string .)


state 42

    (21) EXPR -> let . identifier colon type LETHELPER in EXPR
    (22) EXPR -> let . identifier colon type larrow EXPR LETHELPER in EXPR

    identifier      shift and go to state 69


state 43

    (26) EXPR -> lparen . EXPR rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 70

state 44

    (52) EXPR -> new . type

    type            shift and go to state 71


state 45

    (38) EXPR -> not . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 72

state 46

    (49) EXPR -> true .

    rbrace          reduce using rule 49 (EXPR -> true .)
    at              reduce using rule 49 (EXPR -> true .)
    dot             reduce using rule 49 (EXPR -> true .)
    semi            reduce using rule 49 (EXPR -> true .)
    comma           reduce using rule 49 (EXPR -> true .)
    plus            reduce using rule 49 (EXPR -> true .)
    minus           reduce using rule 49 (EXPR -> true .)
    times           reduce using rule 49 (EXPR -> true .)
    divide          reduce using rule 49 (EXPR -> true .)
    lt              reduce using rule 49 (EXPR -> true .)
    le              reduce using rule 49 (EXPR -> true .)
    equals          reduce using rule 49 (EXPR -> true .)
    in              reduce using rule 49 (EXPR -> true .)
    then            reduce using rule 49 (EXPR -> true .)
    rparen          reduce using rule 49 (EXPR -> true .)
    of              reduce using rule 49 (EXPR -> true .)
    loop            reduce using rule 49 (EXPR -> true .)
    else            reduce using rule 49 (EXPR -> true .)
    pool            reduce using rule 49 (EXPR -> true .)
    fi              reduce using rule 49 (EXPR -> true .)


state 47

    (16) EXPR -> case . EXPR of CASEHELPER esac
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 73

state 48

    (27) EXPR -> lbrace . EXPR semi rbrace
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 74

state 49

    (33) EXPR -> while . EXPR loop EXPR pool
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 75

state 50

    (28) EXPR -> identifier . larrow EXPR
    (29) EXPR -> identifier . lparen EXPR rparen
    (46) EXPR -> identifier .
    (51) EXPR -> identifier . lparen rparen

    larrow          shift and go to state 76
    lparen          shift and go to state 77
    rbrace          reduce using rule 46 (EXPR -> identifier .)
    at              reduce using rule 46 (EXPR -> identifier .)
    dot             reduce using rule 46 (EXPR -> identifier .)
    semi            reduce using rule 46 (EXPR -> identifier .)
    comma           reduce using rule 46 (EXPR -> identifier .)
    plus            reduce using rule 46 (EXPR -> identifier .)
    minus           reduce using rule 46 (EXPR -> identifier .)
    times           reduce using rule 46 (EXPR -> identifier .)
    divide          reduce using rule 46 (EXPR -> identifier .)
    lt              reduce using rule 46 (EXPR -> identifier .)
    le              reduce using rule 46 (EXPR -> identifier .)
    equals          reduce using rule 46 (EXPR -> identifier .)
    then            reduce using rule 46 (EXPR -> identifier .)
    rparen          reduce using rule 46 (EXPR -> identifier .)
    of              reduce using rule 46 (EXPR -> identifier .)
    loop            reduce using rule 46 (EXPR -> identifier .)
    else            reduce using rule 46 (EXPR -> identifier .)
    pool            reduce using rule 46 (EXPR -> identifier .)
    fi              reduce using rule 46 (EXPR -> identifier .)
    in              reduce using rule 46 (EXPR -> identifier .)


state 51

    (8) FEATURE -> identifier lparen rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 78


state 52

    (14) FORMAL -> identifier colon type .

    rparen          reduce using rule 14 (FORMAL -> identifier colon type .)
    comma           reduce using rule 14 (FORMAL -> identifier colon type .)


state 53

    (7) FEATURE -> identifier lparen FORMAL rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 79


state 54

    (15) FORMAL -> FORMAL comma identifier . colon type

    colon           shift and go to state 80


state 55

    (37) EXPR -> tilde EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 37 (EXPR -> tilde EXPR .)
    semi            reduce using rule 37 (EXPR -> tilde EXPR .)
    comma           reduce using rule 37 (EXPR -> tilde EXPR .)
    plus            reduce using rule 37 (EXPR -> tilde EXPR .)
    minus           reduce using rule 37 (EXPR -> tilde EXPR .)
    times           reduce using rule 37 (EXPR -> tilde EXPR .)
    divide          reduce using rule 37 (EXPR -> tilde EXPR .)
    lt              reduce using rule 37 (EXPR -> tilde EXPR .)
    le              reduce using rule 37 (EXPR -> tilde EXPR .)
    equals          reduce using rule 37 (EXPR -> tilde EXPR .)
    in              reduce using rule 37 (EXPR -> tilde EXPR .)
    then            reduce using rule 37 (EXPR -> tilde EXPR .)
    rparen          reduce using rule 37 (EXPR -> tilde EXPR .)
    of              reduce using rule 37 (EXPR -> tilde EXPR .)
    loop            reduce using rule 37 (EXPR -> tilde EXPR .)
    else            reduce using rule 37 (EXPR -> tilde EXPR .)
    pool            reduce using rule 37 (EXPR -> tilde EXPR .)
    fi              reduce using rule 37 (EXPR -> tilde EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67

  ! at              [ reduce using rule 37 (EXPR -> tilde EXPR .) ]
  ! dot             [ reduce using rule 37 (EXPR -> tilde EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! plus            [ shift and go to state 57 ]
  ! minus           [ shift and go to state 66 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 58 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 56

    (32) EXPR -> if EXPR . then EXPR else EXPR fi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    then            shift and go to state 81
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 57

    (39) EXPR -> EXPR plus . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 82

state 58

    (42) EXPR -> EXPR divide . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 83

state 59

    (34) EXPR -> EXPR semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 84

state 60

    (45) EXPR -> EXPR equals . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 85

state 61

    (41) EXPR -> EXPR times . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 86

state 62

    (43) EXPR -> EXPR lt . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 87

state 63

    (44) EXPR -> EXPR le . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 88

state 64

    (19) EXPR -> EXPR at . type dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR at . type dot identifier lparen rparen

    type            shift and go to state 89


state 65

    (35) EXPR -> EXPR comma . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 90

state 66

    (40) EXPR -> EXPR minus . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 91

state 67

    (20) EXPR -> EXPR dot . identifier lparen EXPR rparen
    (31) EXPR -> EXPR dot . identifier lparen rparen

    identifier      shift and go to state 92


state 68

    (36) EXPR -> isvoid EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 36 (EXPR -> isvoid EXPR .)
    semi            reduce using rule 36 (EXPR -> isvoid EXPR .)
    comma           reduce using rule 36 (EXPR -> isvoid EXPR .)
    plus            reduce using rule 36 (EXPR -> isvoid EXPR .)
    minus           reduce using rule 36 (EXPR -> isvoid EXPR .)
    times           reduce using rule 36 (EXPR -> isvoid EXPR .)
    divide          reduce using rule 36 (EXPR -> isvoid EXPR .)
    lt              reduce using rule 36 (EXPR -> isvoid EXPR .)
    le              reduce using rule 36 (EXPR -> isvoid EXPR .)
    equals          reduce using rule 36 (EXPR -> isvoid EXPR .)
    in              reduce using rule 36 (EXPR -> isvoid EXPR .)
    then            reduce using rule 36 (EXPR -> isvoid EXPR .)
    rparen          reduce using rule 36 (EXPR -> isvoid EXPR .)
    of              reduce using rule 36 (EXPR -> isvoid EXPR .)
    loop            reduce using rule 36 (EXPR -> isvoid EXPR .)
    else            reduce using rule 36 (EXPR -> isvoid EXPR .)
    pool            reduce using rule 36 (EXPR -> isvoid EXPR .)
    fi              reduce using rule 36 (EXPR -> isvoid EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67

  ! at              [ reduce using rule 36 (EXPR -> isvoid EXPR .) ]
  ! dot             [ reduce using rule 36 (EXPR -> isvoid EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! plus            [ shift and go to state 57 ]
  ! minus           [ shift and go to state 66 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 58 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 69

    (21) EXPR -> let identifier . colon type LETHELPER in EXPR
    (22) EXPR -> let identifier . colon type larrow EXPR LETHELPER in EXPR

    colon           shift and go to state 93


state 70

    (26) EXPR -> lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 94
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 71

    (52) EXPR -> new type .

    rbrace          reduce using rule 52 (EXPR -> new type .)
    at              reduce using rule 52 (EXPR -> new type .)
    dot             reduce using rule 52 (EXPR -> new type .)
    semi            reduce using rule 52 (EXPR -> new type .)
    comma           reduce using rule 52 (EXPR -> new type .)
    plus            reduce using rule 52 (EXPR -> new type .)
    minus           reduce using rule 52 (EXPR -> new type .)
    times           reduce using rule 52 (EXPR -> new type .)
    divide          reduce using rule 52 (EXPR -> new type .)
    lt              reduce using rule 52 (EXPR -> new type .)
    le              reduce using rule 52 (EXPR -> new type .)
    equals          reduce using rule 52 (EXPR -> new type .)
    in              reduce using rule 52 (EXPR -> new type .)
    then            reduce using rule 52 (EXPR -> new type .)
    rparen          reduce using rule 52 (EXPR -> new type .)
    of              reduce using rule 52 (EXPR -> new type .)
    loop            reduce using rule 52 (EXPR -> new type .)
    else            reduce using rule 52 (EXPR -> new type .)
    pool            reduce using rule 52 (EXPR -> new type .)
    fi              reduce using rule 52 (EXPR -> new type .)


state 72

    (38) EXPR -> not EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 38 (EXPR -> not EXPR .)
    semi            reduce using rule 38 (EXPR -> not EXPR .)
    comma           reduce using rule 38 (EXPR -> not EXPR .)
    in              reduce using rule 38 (EXPR -> not EXPR .)
    then            reduce using rule 38 (EXPR -> not EXPR .)
    rparen          reduce using rule 38 (EXPR -> not EXPR .)
    of              reduce using rule 38 (EXPR -> not EXPR .)
    loop            reduce using rule 38 (EXPR -> not EXPR .)
    else            reduce using rule 38 (EXPR -> not EXPR .)
    pool            reduce using rule 38 (EXPR -> not EXPR .)
    fi              reduce using rule 38 (EXPR -> not EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! at              [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! dot             [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! plus            [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! minus           [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! times           [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! divide          [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! lt              [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! le              [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! equals          [ reduce using rule 38 (EXPR -> not EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]


state 73

    (16) EXPR -> case EXPR . of CASEHELPER esac
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    of              shift and go to state 95
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 74

    (27) EXPR -> lbrace EXPR . semi rbrace
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 96
    at              shift and go to state 64
    dot             shift and go to state 67
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 75

    (33) EXPR -> while EXPR . loop EXPR pool
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    loop            shift and go to state 97
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 76

    (28) EXPR -> identifier larrow . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 98

state 77

    (29) EXPR -> identifier lparen . EXPR rparen
    (51) EXPR -> identifier lparen . rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    rparen          shift and go to state 100
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 99

state 78

    (8) FEATURE -> identifier lparen rparen colon type lbrace . EXPR rbrace
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 101

state 79

    (7) FEATURE -> identifier lparen FORMAL rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 102


state 80

    (15) FORMAL -> FORMAL comma identifier colon . type

    type            shift and go to state 103


state 81

    (32) EXPR -> if EXPR then . EXPR else EXPR fi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 104

state 82

    (39) EXPR -> EXPR plus EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    semi            reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    comma           reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    plus            reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    lt              reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    le              reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    in              reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    then            reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    rparen          reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    of              reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    loop            reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    pool            reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    fi              reduce using rule 39 (EXPR -> EXPR plus EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    times           shift and go to state 61
    divide          shift and go to state 58

  ! at              [ reduce using rule 39 (EXPR -> EXPR plus EXPR .) ]
  ! dot             [ reduce using rule 39 (EXPR -> EXPR plus EXPR .) ]
  ! times           [ reduce using rule 39 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 39 (EXPR -> EXPR plus EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! plus            [ shift and go to state 57 ]
  ! minus           [ shift and go to state 66 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 83

    (42) EXPR -> EXPR divide EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    semi            reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    comma           reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    plus            reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    lt              reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    le              reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    in              reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    then            reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    rparen          reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    of              reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    loop            reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    pool            reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    fi              reduce using rule 42 (EXPR -> EXPR divide EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67

  ! at              [ reduce using rule 42 (EXPR -> EXPR divide EXPR .) ]
  ! dot             [ reduce using rule 42 (EXPR -> EXPR divide EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! plus            [ shift and go to state 57 ]
  ! minus           [ shift and go to state 66 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 58 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 84

    (34) EXPR -> EXPR semi EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    in              reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    then            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    rparen          reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    of              reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    loop            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    else            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    pool            reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    fi              reduce using rule 34 (EXPR -> EXPR semi EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! at              [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! dot             [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! semi            [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! comma           [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! plus            [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! minus           [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! times           [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! divide          [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! lt              [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! le              [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]
  ! equals          [ reduce using rule 34 (EXPR -> EXPR semi EXPR .) ]


state 85

    (45) EXPR -> EXPR equals EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    semi            reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    comma           reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    lt              reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    le              reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    equals          reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    in              reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    then            reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    rparen          reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    of              reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    loop            reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    else            reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    pool            reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    fi              reduce using rule 45 (EXPR -> EXPR equals EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58

  ! at              [ reduce using rule 45 (EXPR -> EXPR equals EXPR .) ]
  ! dot             [ reduce using rule 45 (EXPR -> EXPR equals EXPR .) ]
  ! plus            [ reduce using rule 45 (EXPR -> EXPR equals EXPR .) ]
  ! minus           [ reduce using rule 45 (EXPR -> EXPR equals EXPR .) ]
  ! times           [ reduce using rule 45 (EXPR -> EXPR equals EXPR .) ]
  ! divide          [ reduce using rule 45 (EXPR -> EXPR equals EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 86

    (41) EXPR -> EXPR times EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 41 (EXPR -> EXPR times EXPR .)
    semi            reduce using rule 41 (EXPR -> EXPR times EXPR .)
    comma           reduce using rule 41 (EXPR -> EXPR times EXPR .)
    plus            reduce using rule 41 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 41 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 41 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 41 (EXPR -> EXPR times EXPR .)
    lt              reduce using rule 41 (EXPR -> EXPR times EXPR .)
    le              reduce using rule 41 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 41 (EXPR -> EXPR times EXPR .)
    in              reduce using rule 41 (EXPR -> EXPR times EXPR .)
    then            reduce using rule 41 (EXPR -> EXPR times EXPR .)
    rparen          reduce using rule 41 (EXPR -> EXPR times EXPR .)
    of              reduce using rule 41 (EXPR -> EXPR times EXPR .)
    loop            reduce using rule 41 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 41 (EXPR -> EXPR times EXPR .)
    pool            reduce using rule 41 (EXPR -> EXPR times EXPR .)
    fi              reduce using rule 41 (EXPR -> EXPR times EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67

  ! at              [ reduce using rule 41 (EXPR -> EXPR times EXPR .) ]
  ! dot             [ reduce using rule 41 (EXPR -> EXPR times EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! plus            [ shift and go to state 57 ]
  ! minus           [ shift and go to state 66 ]
  ! times           [ shift and go to state 61 ]
  ! divide          [ shift and go to state 58 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 87

    (43) EXPR -> EXPR lt EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    semi            reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    comma           reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    lt              reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    le              reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    equals          reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    in              reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    then            reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    rparen          reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    of              reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    loop            reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    else            reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    pool            reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    fi              reduce using rule 43 (EXPR -> EXPR lt EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58

  ! at              [ reduce using rule 43 (EXPR -> EXPR lt EXPR .) ]
  ! dot             [ reduce using rule 43 (EXPR -> EXPR lt EXPR .) ]
  ! plus            [ reduce using rule 43 (EXPR -> EXPR lt EXPR .) ]
  ! minus           [ reduce using rule 43 (EXPR -> EXPR lt EXPR .) ]
  ! times           [ reduce using rule 43 (EXPR -> EXPR lt EXPR .) ]
  ! divide          [ reduce using rule 43 (EXPR -> EXPR lt EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 88

    (44) EXPR -> EXPR le EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 44 (EXPR -> EXPR le EXPR .)
    semi            reduce using rule 44 (EXPR -> EXPR le EXPR .)
    comma           reduce using rule 44 (EXPR -> EXPR le EXPR .)
    lt              reduce using rule 44 (EXPR -> EXPR le EXPR .)
    le              reduce using rule 44 (EXPR -> EXPR le EXPR .)
    equals          reduce using rule 44 (EXPR -> EXPR le EXPR .)
    in              reduce using rule 44 (EXPR -> EXPR le EXPR .)
    then            reduce using rule 44 (EXPR -> EXPR le EXPR .)
    rparen          reduce using rule 44 (EXPR -> EXPR le EXPR .)
    of              reduce using rule 44 (EXPR -> EXPR le EXPR .)
    loop            reduce using rule 44 (EXPR -> EXPR le EXPR .)
    else            reduce using rule 44 (EXPR -> EXPR le EXPR .)
    pool            reduce using rule 44 (EXPR -> EXPR le EXPR .)
    fi              reduce using rule 44 (EXPR -> EXPR le EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58

  ! at              [ reduce using rule 44 (EXPR -> EXPR le EXPR .) ]
  ! dot             [ reduce using rule 44 (EXPR -> EXPR le EXPR .) ]
  ! plus            [ reduce using rule 44 (EXPR -> EXPR le EXPR .) ]
  ! minus           [ reduce using rule 44 (EXPR -> EXPR le EXPR .) ]
  ! times           [ reduce using rule 44 (EXPR -> EXPR le EXPR .) ]
  ! divide          [ reduce using rule 44 (EXPR -> EXPR le EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 89

    (19) EXPR -> EXPR at type . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR at type . dot identifier lparen rparen

    dot             shift and go to state 105


state 90

    (35) EXPR -> EXPR comma EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    in              reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    then            reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    rparen          reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    of              reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    loop            reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    else            reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    pool            reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    fi              reduce using rule 35 (EXPR -> EXPR comma EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! at              [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! dot             [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! semi            [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! comma           [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! plus            [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! minus           [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! times           [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! divide          [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! lt              [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! le              [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]
  ! equals          [ reduce using rule 35 (EXPR -> EXPR comma EXPR .) ]


state 91

    (40) EXPR -> EXPR minus EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    semi            reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    comma           reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    plus            reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    lt              reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    le              reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    in              reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    then            reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    rparen          reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    of              reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    loop            reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    pool            reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    fi              reduce using rule 40 (EXPR -> EXPR minus EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    times           shift and go to state 61
    divide          shift and go to state 58

  ! at              [ reduce using rule 40 (EXPR -> EXPR minus EXPR .) ]
  ! dot             [ reduce using rule 40 (EXPR -> EXPR minus EXPR .) ]
  ! times           [ reduce using rule 40 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 40 (EXPR -> EXPR minus EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]
  ! plus            [ shift and go to state 57 ]
  ! minus           [ shift and go to state 66 ]
  ! lt              [ shift and go to state 62 ]
  ! le              [ shift and go to state 63 ]
  ! equals          [ shift and go to state 60 ]


state 92

    (20) EXPR -> EXPR dot identifier . lparen EXPR rparen
    (31) EXPR -> EXPR dot identifier . lparen rparen

    lparen          shift and go to state 106


state 93

    (21) EXPR -> let identifier colon . type LETHELPER in EXPR
    (22) EXPR -> let identifier colon . type larrow EXPR LETHELPER in EXPR

    type            shift and go to state 107


state 94

    (26) EXPR -> lparen EXPR rparen .

    rbrace          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    at              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    dot             reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    semi            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    comma           reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    plus            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    minus           reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    times           reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    divide          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    lt              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    le              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    equals          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    in              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    then            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    rparen          reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    of              reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    loop            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    else            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    pool            reduce using rule 26 (EXPR -> lparen EXPR rparen .)
    fi              reduce using rule 26 (EXPR -> lparen EXPR rparen .)


state 95

    (16) EXPR -> case EXPR of . CASEHELPER esac
    (17) CASEHELPER -> . identifier colon type rarrow EXPR semi
    (18) CASEHELPER -> . CASEHELPER identifier colon type rarrow EXPR semi

    identifier      shift and go to state 109

    CASEHELPER                     shift and go to state 108

state 96

    (27) EXPR -> lbrace EXPR semi . rbrace
    (34) EXPR -> EXPR semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    rbrace          shift and go to state 110
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 84

state 97

    (33) EXPR -> while EXPR loop . EXPR pool
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 111

state 98

    (28) EXPR -> identifier larrow EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    semi            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    comma           reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    in              reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    then            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    rparen          reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    of              reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    loop            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    else            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    pool            reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    fi              reduce using rule 28 (EXPR -> identifier larrow EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! at              [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! dot             [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! plus            [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! minus           [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! times           [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! divide          [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! lt              [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! le              [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! equals          [ reduce using rule 28 (EXPR -> identifier larrow EXPR .) ]
  ! semi            [ shift and go to state 59 ]
  ! comma           [ shift and go to state 65 ]


state 99

    (29) EXPR -> identifier lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 112
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 100

    (51) EXPR -> identifier lparen rparen .

    rbrace          reduce using rule 51 (EXPR -> identifier lparen rparen .)
    at              reduce using rule 51 (EXPR -> identifier lparen rparen .)
    dot             reduce using rule 51 (EXPR -> identifier lparen rparen .)
    semi            reduce using rule 51 (EXPR -> identifier lparen rparen .)
    comma           reduce using rule 51 (EXPR -> identifier lparen rparen .)
    plus            reduce using rule 51 (EXPR -> identifier lparen rparen .)
    minus           reduce using rule 51 (EXPR -> identifier lparen rparen .)
    times           reduce using rule 51 (EXPR -> identifier lparen rparen .)
    divide          reduce using rule 51 (EXPR -> identifier lparen rparen .)
    lt              reduce using rule 51 (EXPR -> identifier lparen rparen .)
    le              reduce using rule 51 (EXPR -> identifier lparen rparen .)
    equals          reduce using rule 51 (EXPR -> identifier lparen rparen .)
    in              reduce using rule 51 (EXPR -> identifier lparen rparen .)
    then            reduce using rule 51 (EXPR -> identifier lparen rparen .)
    rparen          reduce using rule 51 (EXPR -> identifier lparen rparen .)
    of              reduce using rule 51 (EXPR -> identifier lparen rparen .)
    loop            reduce using rule 51 (EXPR -> identifier lparen rparen .)
    else            reduce using rule 51 (EXPR -> identifier lparen rparen .)
    pool            reduce using rule 51 (EXPR -> identifier lparen rparen .)
    fi              reduce using rule 51 (EXPR -> identifier lparen rparen .)


state 101

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR . rbrace
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 113
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 102

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace . EXPR rbrace
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 114

state 103

    (15) FORMAL -> FORMAL comma identifier colon type .

    rparen          reduce using rule 15 (FORMAL -> FORMAL comma identifier colon type .)
    comma           reduce using rule 15 (FORMAL -> FORMAL comma identifier colon type .)


state 104

    (32) EXPR -> if EXPR then EXPR . else EXPR fi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    else            shift and go to state 115
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 105

    (19) EXPR -> EXPR at type dot . identifier lparen EXPR rparen
    (30) EXPR -> EXPR at type dot . identifier lparen rparen

    identifier      shift and go to state 116


state 106

    (20) EXPR -> EXPR dot identifier lparen . EXPR rparen
    (31) EXPR -> EXPR dot identifier lparen . rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    rparen          shift and go to state 118
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 117

state 107

    (21) EXPR -> let identifier colon type . LETHELPER in EXPR
    (22) EXPR -> let identifier colon type . larrow EXPR LETHELPER in EXPR
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .

    larrow          shift and go to state 120
    comma           shift and go to state 119
    in              reduce using rule 25 (LETHELPER -> .)

    LETHELPER                      shift and go to state 121

state 108

    (16) EXPR -> case EXPR of CASEHELPER . esac
    (18) CASEHELPER -> CASEHELPER . identifier colon type rarrow EXPR semi

    esac            shift and go to state 122
    identifier      shift and go to state 123


state 109

    (17) CASEHELPER -> identifier . colon type rarrow EXPR semi

    colon           shift and go to state 124


state 110

    (27) EXPR -> lbrace EXPR semi rbrace .

    rbrace          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    at              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    dot             reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    semi            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    comma           reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    plus            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    minus           reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    times           reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    divide          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    lt              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    le              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    equals          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    in              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    then            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    rparen          reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    of              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    loop            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    else            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    pool            reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)
    fi              reduce using rule 27 (EXPR -> lbrace EXPR semi rbrace .)


state 111

    (33) EXPR -> while EXPR loop EXPR . pool
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    pool            shift and go to state 125
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 112

    (29) EXPR -> identifier lparen EXPR rparen .

    rbrace          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    at              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    dot             reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    semi            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    comma           reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    plus            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    minus           reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    times           reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    divide          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    lt              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    le              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    equals          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    in              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    then            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    rparen          reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    of              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    loop            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    else            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    pool            reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)
    fi              reduce using rule 29 (EXPR -> identifier lparen EXPR rparen .)


state 113

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 8 (FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .)


state 114

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR . rbrace
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 126
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 115

    (32) EXPR -> if EXPR then EXPR else . EXPR fi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 127

state 116

    (19) EXPR -> EXPR at type dot identifier . lparen EXPR rparen
    (30) EXPR -> EXPR at type dot identifier . lparen rparen

    lparen          shift and go to state 128


state 117

    (20) EXPR -> EXPR dot identifier lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 129
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 118

    (31) EXPR -> EXPR dot identifier lparen rparen .

    rbrace          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    at              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    dot             reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    semi            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    comma           reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    plus            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    minus           reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    times           reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    divide          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    lt              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    le              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    equals          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    in              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    then            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    rparen          reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    of              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    loop            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    else            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    pool            reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)
    fi              reduce using rule 31 (EXPR -> EXPR dot identifier lparen rparen .)


state 119

    (23) LETHELPER -> comma . identifier colon type LETHELPER
    (24) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER

    identifier      shift and go to state 130


state 120

    (22) EXPR -> let identifier colon type larrow . EXPR LETHELPER in EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 131

state 121

    (21) EXPR -> let identifier colon type LETHELPER . in EXPR

    in              shift and go to state 132


state 122

    (16) EXPR -> case EXPR of CASEHELPER esac .

    rbrace          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    at              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    dot             reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    semi            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    comma           reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    plus            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    minus           reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    times           reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    divide          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    lt              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    le              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    equals          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    in              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    then            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    rparen          reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    of              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    loop            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    else            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    pool            reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)
    fi              reduce using rule 16 (EXPR -> case EXPR of CASEHELPER esac .)


state 123

    (18) CASEHELPER -> CASEHELPER identifier . colon type rarrow EXPR semi

    colon           shift and go to state 133


state 124

    (17) CASEHELPER -> identifier colon . type rarrow EXPR semi

    type            shift and go to state 134


state 125

    (33) EXPR -> while EXPR loop EXPR pool .

    rbrace          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    at              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    dot             reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    semi            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    comma           reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    plus            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    minus           reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    times           reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    divide          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    lt              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    le              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    equals          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    in              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    then            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    rparen          reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    of              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    loop            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    else            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    pool            reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)
    fi              reduce using rule 33 (EXPR -> while EXPR loop EXPR pool .)


state 126

    (7) FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 7 (FEATURE -> identifier lparen FORMAL rparen colon type lbrace EXPR rbrace .)


state 127

    (32) EXPR -> if EXPR then EXPR else EXPR . fi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    fi              shift and go to state 135
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 128

    (19) EXPR -> EXPR at type dot identifier lparen . EXPR rparen
    (30) EXPR -> EXPR at type dot identifier lparen . rparen
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    rparen          shift and go to state 137
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 136

state 129

    (20) EXPR -> EXPR dot identifier lparen EXPR rparen .

    rbrace          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    at              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    dot             reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    semi            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    comma           reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    plus            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    minus           reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    times           reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    divide          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    lt              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    le              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    equals          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    in              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    then            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    of              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    loop            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    else            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    pool            reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)
    fi              reduce using rule 20 (EXPR -> EXPR dot identifier lparen EXPR rparen .)


state 130

    (23) LETHELPER -> comma identifier . colon type LETHELPER
    (24) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER

    colon           shift and go to state 138


state 131

    (22) EXPR -> let identifier colon type larrow EXPR . LETHELPER in EXPR
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .

    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 139
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60
    in              reduce using rule 25 (LETHELPER -> .)

    LETHELPER                      shift and go to state 140

state 132

    (21) EXPR -> let identifier colon type LETHELPER in . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 141

state 133

    (18) CASEHELPER -> CASEHELPER identifier colon . type rarrow EXPR semi

    type            shift and go to state 142


state 134

    (17) CASEHELPER -> identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 143


state 135

    (32) EXPR -> if EXPR then EXPR else EXPR fi .

    rbrace          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    at              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    dot             reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    semi            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    comma           reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    plus            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    minus           reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    times           reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    divide          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    lt              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    le              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    equals          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    in              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    then            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rparen          reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    of              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    loop            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    else            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    pool            reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)
    fi              reduce using rule 32 (EXPR -> if EXPR then EXPR else EXPR fi .)


state 136

    (19) EXPR -> EXPR at type dot identifier lparen EXPR . rparen
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 144
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 137

    (30) EXPR -> EXPR at type dot identifier lparen rparen .

    rbrace          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    at              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    dot             reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    semi            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    comma           reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    plus            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    minus           reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    times           reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    divide          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    lt              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    le              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    equals          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    in              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    then            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rparen          reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    of              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    loop            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    else            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    pool            reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)
    fi              reduce using rule 30 (EXPR -> EXPR at type dot identifier lparen rparen .)


state 138

    (23) LETHELPER -> comma identifier colon . type LETHELPER
    (24) LETHELPER -> comma identifier colon . type larrow EXPR LETHELPER

    type            shift and go to state 145


state 139

    (35) EXPR -> EXPR comma . EXPR
    (23) LETHELPER -> comma . identifier colon type LETHELPER
    (24) LETHELPER -> comma . identifier colon type larrow EXPR LETHELPER
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    identifier      shift and go to state 146
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 90

state 140

    (22) EXPR -> let identifier colon type larrow EXPR LETHELPER . in EXPR

    in              shift and go to state 147


state 141

    (21) EXPR -> let identifier colon type LETHELPER in EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    in              reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    then            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    rparen          reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    of              reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    loop            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    else            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    pool            reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    fi              reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! at              [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 21 (EXPR -> let identifier colon type LETHELPER in EXPR .) ]


state 142

    (18) CASEHELPER -> CASEHELPER identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 148


state 143

    (17) CASEHELPER -> identifier colon type rarrow . EXPR semi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 149

state 144

    (19) EXPR -> EXPR at type dot identifier lparen EXPR rparen .

    rbrace          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    at              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    dot             reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    semi            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    comma           reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    plus            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    minus           reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    times           reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    divide          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    lt              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    le              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    equals          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    in              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    then            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    rparen          reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    of              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    loop            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    else            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    pool            reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)
    fi              reduce using rule 19 (EXPR -> EXPR at type dot identifier lparen EXPR rparen .)


state 145

    (23) LETHELPER -> comma identifier colon type . LETHELPER
    (24) LETHELPER -> comma identifier colon type . larrow EXPR LETHELPER
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .

    larrow          shift and go to state 150
    comma           shift and go to state 119
    in              reduce using rule 25 (LETHELPER -> .)

    LETHELPER                      shift and go to state 151

state 146

    (23) LETHELPER -> comma identifier . colon type LETHELPER
    (24) LETHELPER -> comma identifier . colon type larrow EXPR LETHELPER
    (28) EXPR -> identifier . larrow EXPR
    (29) EXPR -> identifier . lparen EXPR rparen
    (46) EXPR -> identifier .
    (51) EXPR -> identifier . lparen rparen

    colon           shift and go to state 138
    larrow          shift and go to state 76
    lparen          shift and go to state 77
    at              reduce using rule 46 (EXPR -> identifier .)
    dot             reduce using rule 46 (EXPR -> identifier .)
    semi            reduce using rule 46 (EXPR -> identifier .)
    comma           reduce using rule 46 (EXPR -> identifier .)
    plus            reduce using rule 46 (EXPR -> identifier .)
    minus           reduce using rule 46 (EXPR -> identifier .)
    times           reduce using rule 46 (EXPR -> identifier .)
    divide          reduce using rule 46 (EXPR -> identifier .)
    lt              reduce using rule 46 (EXPR -> identifier .)
    le              reduce using rule 46 (EXPR -> identifier .)
    equals          reduce using rule 46 (EXPR -> identifier .)
    in              reduce using rule 46 (EXPR -> identifier .)


state 147

    (22) EXPR -> let identifier colon type larrow EXPR LETHELPER in . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 152

state 148

    (18) CASEHELPER -> CASEHELPER identifier colon type rarrow . EXPR semi
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 153

state 149

    (17) CASEHELPER -> identifier colon type rarrow EXPR . semi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 154
    at              shift and go to state 64
    dot             shift and go to state 67
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 150

    (24) LETHELPER -> comma identifier colon type larrow . EXPR LETHELPER
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

    EXPR                           shift and go to state 155

state 151

    (23) LETHELPER -> comma identifier colon type LETHELPER .

    in              reduce using rule 23 (LETHELPER -> comma identifier colon type LETHELPER .)


state 152

    (22) EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for semi resolved as shift
  ! shift/reduce conflict for comma resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    in              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    then            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    rparen          reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    of              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    loop            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    else            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    pool            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    fi              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .)
    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60

  ! at              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! dot             [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! semi            [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! comma           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! plus            [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! minus           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! times           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! divide          [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! lt              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! le              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]
  ! equals          [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR LETHELPER in EXPR .) ]


state 153

    (18) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR . semi
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 156
    at              shift and go to state 64
    dot             shift and go to state 67
    comma           shift and go to state 65
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60


state 154

    (17) CASEHELPER -> identifier colon type rarrow EXPR semi .
    (34) EXPR -> EXPR semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 17 (CASEHELPER -> identifier colon type rarrow EXPR semi .)
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

  ! identifier      [ reduce using rule 17 (CASEHELPER -> identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 84

state 155

    (24) LETHELPER -> comma identifier colon type larrow EXPR . LETHELPER
    (19) EXPR -> EXPR . at type dot identifier lparen EXPR rparen
    (20) EXPR -> EXPR . dot identifier lparen EXPR rparen
    (30) EXPR -> EXPR . at type dot identifier lparen rparen
    (31) EXPR -> EXPR . dot identifier lparen rparen
    (34) EXPR -> EXPR . semi EXPR
    (35) EXPR -> EXPR . comma EXPR
    (39) EXPR -> EXPR . plus EXPR
    (40) EXPR -> EXPR . minus EXPR
    (41) EXPR -> EXPR . times EXPR
    (42) EXPR -> EXPR . divide EXPR
    (43) EXPR -> EXPR . lt EXPR
    (44) EXPR -> EXPR . le EXPR
    (45) EXPR -> EXPR . equals EXPR
    (23) LETHELPER -> . comma identifier colon type LETHELPER
    (24) LETHELPER -> . comma identifier colon type larrow EXPR LETHELPER
    (25) LETHELPER -> .

    at              shift and go to state 64
    dot             shift and go to state 67
    semi            shift and go to state 59
    comma           shift and go to state 139
    plus            shift and go to state 57
    minus           shift and go to state 66
    times           shift and go to state 61
    divide          shift and go to state 58
    lt              shift and go to state 62
    le              shift and go to state 63
    equals          shift and go to state 60
    in              reduce using rule 25 (LETHELPER -> .)

    LETHELPER                      shift and go to state 157

state 156

    (18) CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .
    (34) EXPR -> EXPR semi . EXPR
    (16) EXPR -> . case EXPR of CASEHELPER esac
    (19) EXPR -> . EXPR at type dot identifier lparen EXPR rparen
    (20) EXPR -> . EXPR dot identifier lparen EXPR rparen
    (21) EXPR -> . let identifier colon type LETHELPER in EXPR
    (22) EXPR -> . let identifier colon type larrow EXPR LETHELPER in EXPR
    (26) EXPR -> . lparen EXPR rparen
    (27) EXPR -> . lbrace EXPR semi rbrace
    (28) EXPR -> . identifier larrow EXPR
    (29) EXPR -> . identifier lparen EXPR rparen
    (30) EXPR -> . EXPR at type dot identifier lparen rparen
    (31) EXPR -> . EXPR dot identifier lparen rparen
    (32) EXPR -> . if EXPR then EXPR else EXPR fi
    (33) EXPR -> . while EXPR loop EXPR pool
    (34) EXPR -> . EXPR semi EXPR
    (35) EXPR -> . EXPR comma EXPR
    (36) EXPR -> . isvoid EXPR
    (37) EXPR -> . tilde EXPR
    (38) EXPR -> . not EXPR
    (39) EXPR -> . EXPR plus EXPR
    (40) EXPR -> . EXPR minus EXPR
    (41) EXPR -> . EXPR times EXPR
    (42) EXPR -> . EXPR divide EXPR
    (43) EXPR -> . EXPR lt EXPR
    (44) EXPR -> . EXPR le EXPR
    (45) EXPR -> . EXPR equals EXPR
    (46) EXPR -> . identifier
    (47) EXPR -> . integer
    (48) EXPR -> . string
    (49) EXPR -> . true
    (50) EXPR -> . false
    (51) EXPR -> . identifier lparen rparen
    (52) EXPR -> . new type

  ! shift/reduce conflict for identifier resolved as shift
    esac            reduce using rule 18 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .)
    case            shift and go to state 47
    let             shift and go to state 42
    lparen          shift and go to state 43
    lbrace          shift and go to state 48
    identifier      shift and go to state 50
    if              shift and go to state 37
    while           shift and go to state 49
    isvoid          shift and go to state 40
    tilde           shift and go to state 36
    not             shift and go to state 45
    integer         shift and go to state 38
    string          shift and go to state 41
    true            shift and go to state 46
    false           shift and go to state 35
    new             shift and go to state 44

  ! identifier      [ reduce using rule 18 (CASEHELPER -> CASEHELPER identifier colon type rarrow EXPR semi .) ]

    EXPR                           shift and go to state 84

state 157

    (24) LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .

    in              reduce using rule 24 (LETHELPER -> comma identifier colon type larrow EXPR LETHELPER .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for identifier in state 9 resolved as shift
WARNING: shift/reduce conflict for identifier in state 13 resolved as shift
WARNING: shift/reduce conflict for identifier in state 15 resolved as shift
WARNING: shift/reduce conflict for semi in state 17 resolved as shift
WARNING: shift/reduce conflict for at in state 84 resolved as shift
WARNING: shift/reduce conflict for dot in state 84 resolved as shift
WARNING: shift/reduce conflict for semi in state 84 resolved as shift
WARNING: shift/reduce conflict for comma in state 84 resolved as shift
WARNING: shift/reduce conflict for plus in state 84 resolved as shift
WARNING: shift/reduce conflict for minus in state 84 resolved as shift
WARNING: shift/reduce conflict for times in state 84 resolved as shift
WARNING: shift/reduce conflict for divide in state 84 resolved as shift
WARNING: shift/reduce conflict for lt in state 84 resolved as shift
WARNING: shift/reduce conflict for le in state 84 resolved as shift
WARNING: shift/reduce conflict for equals in state 84 resolved as shift
WARNING: shift/reduce conflict for at in state 90 resolved as shift
WARNING: shift/reduce conflict for dot in state 90 resolved as shift
WARNING: shift/reduce conflict for semi in state 90 resolved as shift
WARNING: shift/reduce conflict for comma in state 90 resolved as shift
WARNING: shift/reduce conflict for plus in state 90 resolved as shift
WARNING: shift/reduce conflict for minus in state 90 resolved as shift
WARNING: shift/reduce conflict for times in state 90 resolved as shift
WARNING: shift/reduce conflict for divide in state 90 resolved as shift
WARNING: shift/reduce conflict for lt in state 90 resolved as shift
WARNING: shift/reduce conflict for le in state 90 resolved as shift
WARNING: shift/reduce conflict for equals in state 90 resolved as shift
WARNING: shift/reduce conflict for at in state 141 resolved as shift
WARNING: shift/reduce conflict for dot in state 141 resolved as shift
WARNING: shift/reduce conflict for semi in state 141 resolved as shift
WARNING: shift/reduce conflict for comma in state 141 resolved as shift
WARNING: shift/reduce conflict for plus in state 141 resolved as shift
WARNING: shift/reduce conflict for minus in state 141 resolved as shift
WARNING: shift/reduce conflict for times in state 141 resolved as shift
WARNING: shift/reduce conflict for divide in state 141 resolved as shift
WARNING: shift/reduce conflict for lt in state 141 resolved as shift
WARNING: shift/reduce conflict for le in state 141 resolved as shift
WARNING: shift/reduce conflict for equals in state 141 resolved as shift
WARNING: shift/reduce conflict for at in state 152 resolved as shift
WARNING: shift/reduce conflict for dot in state 152 resolved as shift
WARNING: shift/reduce conflict for semi in state 152 resolved as shift
WARNING: shift/reduce conflict for comma in state 152 resolved as shift
WARNING: shift/reduce conflict for plus in state 152 resolved as shift
WARNING: shift/reduce conflict for minus in state 152 resolved as shift
WARNING: shift/reduce conflict for times in state 152 resolved as shift
WARNING: shift/reduce conflict for divide in state 152 resolved as shift
WARNING: shift/reduce conflict for lt in state 152 resolved as shift
WARNING: shift/reduce conflict for le in state 152 resolved as shift
WARNING: shift/reduce conflict for equals in state 152 resolved as shift
WARNING: shift/reduce conflict for identifier in state 154 resolved as shift
WARNING: shift/reduce conflict for identifier in state 156 resolved as shift
